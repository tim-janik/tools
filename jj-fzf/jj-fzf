#!/bin/bash
# This Source Code Form is licensed MPL-2.0: http://mozilla.org/MPL/2.0
set -Eeuo pipefail #-x
SCRIPTNAME=`basename $0` && function die  { [ -n "$*" ] && echo "$SCRIPTNAME: $*" >&2; exit 127 ; }
SELF="$0"

# == Config ==
# JJ repository
JJROOT=$(jj --ignore-working-copy root) || die "$PWD: not a JJ repository"
JJFZFSHOW="jj --no-pager --ignore-working-copy show --tool true"
JJFZFONELINE="jj --no-pager --ignore-working-copy log --no-graph --color=always -T builtin_log_oneline"
JJFZFPAGER="less -Rc"
FZFSETTINGS=(
  --ansi --no-mouse
  --info default
  --layout reverse-list
  --scroll-off 3
  --bind "ctrl-x:jump"
  --bind "ctrl-z:ignore"
  --bind='f11:change-preview-window(bottom,75%,border-horizontal|)'
  --preview-window 'right,border-left'
)
FZFPOPUP=(fzf "${FZFSETTINGS[@]}" --margin 0,2%,5%,2% --border)
TEMPD=

# == Utils ==
# Create temporary dir, assigns $TEMPD
temp_dir()
{
  test -n "$TEMPD" || {
    TEMPD="`mktemp --tmpdir -d jjfzf0XXXXXX`" || die "mktemp failed"
    trap "rm -rf '$TEMPD'" 0 HUP INT QUIT TRAP USR1 PIPE TERM
  }
}
# Match JJ revision as first ASCII word (e.g. as in builtin_log_oneline)
REVPAT='^[^a-z()0-9]*([k-xyz]{7,})\ '
# Extract JJ revision from first word
xrev()
(
  if [[ "$* " =~ $REVPAT ]] ; then	# jj log line
    rev_changeid "${BASH_REMATCH[1]}"
  elif [[ "$*" =~ ^([^\ ]+)$ ]] ; then	# revision identifier w/o whitespace
    rev_changeid "${BASH_REMATCH[1]}"
  fi
)
# Look up full revision via JJ change_id
rev_changeid()	( $JJFZFSHOW -T 'change_id' -r "$1" )
# Look up full commit hash via JJ commit_id
rev_commitid()	( $JJFZFSHOW -T 'commit_id' -r "$1" )
# List all branches of a revision
rev_branches()	( $JJFZFSHOW -T 'concat(separate(" ",branches))' -r "$1" )
# Get revision description
rev_description() ( $JJFZFSHOW -T 'concat(description)' -r "$1" )
# Condense commit empty/description/parent state into a key word
rev_edpstate()
(
  export EDPSTATE='separate("-", if(empty, "empty", "diff"), if(description, "description", "silent"), "p" ++ self.parents().len()) ++ "\n"'
  $JJFZFSHOW -r "$1" -T "$EDPSTATE" # empty-description-p2 diff-silent-p1 etc
)
# Require .git directory and set GIT_DIR
require_git_dir()
{
  test -e "$JJROOT/.git" &&
    export GIT_DIR="$JJROOT/.git" || {
      test -e "$JJROOT/.jj/repo/store/git" &&
	export GIT_DIR="$JJROOT/.jj/repo/store/git" ||
	  die "$PWD: failed to find .git store"
    }
}
MESSAGE()
{
  echo "#${FUNC:+ $FUNC:}" "$*"
}
ERROR()
{
  FUNC="${FUNC:-$0}"
  echo "ERROR: ${FUNC:+$FUNC:}" "$*" >&2
  read -t 2
  exit
}

# == Helpers ==
# Echo signoff
echo_signoff()
(
  JJFZF_SIGNOFF=true	# config get jjfzf.signoff
  if test "${JJFZF_SIGNOFF:-true}" == true ; then
    echo # separating newline before signoff section
    $JJFZFSHOW -T 'format_detailed_signature(author) ++ "\n"' -r @ |
      sed -e 's/>.*/>/ ; s/^/Signed-off-by: /'
  fi
)
# Echo current or default message
echo_commit_msg()
(
  R="$1"
  S=$(rev_edpstate "$R")
  # keep existing message
  [[ $S =~ -silent- ]] || {
    rev_description "$R"
    return
  }
  # start with file name prefixes
  cd "$JJROOT" # create root relative file names
  FILES=()
  readarray -t FILES < <(jj log --no-graph -r "$R" -T '' -s | sed 's/^\w //')
  test ${#FILES[@]} -gt 0 &&
    printf "%s: \n" "${FILES[@]}" ||
      echo Empty...
  # ensure signoff
  echo_signoff
)
# Run user editor: user_editor_on_var <FILE> <VARIABLE>
user_editor_on_var()
{
  local FILE="$1" N=
  declare -n _ueovMSG="$2"			# <VARIABLE> alias
  # create msg file
  temp_dir
  local TEMPFILE="$TEMPD/$FILE"
  cat >"$TEMPFILE" <<<"$_ueovMSG"
  # edit commit msg
  $EDITOR "$TEMPFILE" &&
    N="$(cat "$TEMPFILE")" && {
      test "$_ueovMSG" != "$N" &&
	_ueovMSG="$(cat "$TEMPFILE")"
      rm -f "$TEMPFILE"
      return 0
    }
  rm -f "$TEMPFILE"
  return 1
}

# == Functions ==
FUNCTIONS=()
declare -A KEYBINDINGS

loadlog()
(
  cd "$JJROOT" # create root relative file names
  {
    if test -z "${1:-}" ; then
      # default, show decendants, ancestry around working copy
      jj --no-pager --ignore-working-copy log --color=always -T builtin_log_oneline -r '::@ | @-::'
    elif jj --no-pager --ignore-working-copy log --no-graph -T 'change_id' -r "$1" >/dev/null 2>&1 ; then
      # use valid revset
      jj --no-pager --ignore-working-copy log --color=always -T builtin_log_oneline -r "$1"
    else
      # search pattern, filter on top of all entries
      jj --no-pager --ignore-working-copy log --color=always -T builtin_log_oneline -r :: | {
	grep -P "$1" || # invalid patterns like '*' show full log
	  cat # -P '^\W*$|'"$1"
      }
      # TODO: squash entire description into oneline for grep
    fi
  } | # post process, to give the '@' in --graph a seperate color
    sed -r $'s/^(\W*)@/\\1\e[31;1m@\e[0m/'
)
FUNCTIONS+=( 'loadlog' )

preview()
(
  R="$(xrev "${1:-@}" 2>/dev/null)" &&
    test -n "$R" ||
      exit
  export SHOWDETAILS='
concat(
  builtin_log_oneline,
  "Change ID: " ++ self.change_id() ++ "\n",
  "Commit ID: " ++ commit_id ++ "\n",
  surround("Refs:      ", "\n", separate(" ", local_branches, remote_branches, tags)),
  if(immutable, "Immutable: " ++ label("description placeholder", "true") ++ "\n"),
  "Parents:  " ++ self.parents().map(|c| " " ++ c.change_id()) ++ "\n",
  "Author:    " ++ format_detailed_signature(author) ++ "\n",
  "Committer: " ++ format_detailed_signature(committer)  ++ "\n\n",
  indent("    ",
    coalesce(description, label(if(empty, "empty"), description_placeholder) ++ "\n")),
  "\n",
)'	# extended version of builtin_log_detailed; https://github.com/martinvonz/jj/blob/main/cli/src/config/templates.toml
  E=$'\e\[[0-9;,]*m'	# \e[1;2m - match ANSI escape sequences
  jj --no-pager --ignore-working-copy log --no-graph --color=always -T "$SHOWDETAILS" -s --git -r "$R" |
    sed -r "0,/^(($E)?diff\b)/{s//\n\1/}"	# insert newline between stats and diff
)
FUNCTIONS+=( 'preview' )

# Select Change ID
selectchange()
(
  REVISION="${1:- :: }"
  PROMPT="${2:-> }"
  PREVIEW="${3:-}"
  HEADER="${4:-}"
  test -n "$PREVIEW" || PREVIEW="$SELF preview {} {q}"
  REV=$("${FZFPOPUP[@]}" \
	  --no-sort \
	  --prompt "$PROMPT" \
	  --preview "[[ {} =~ $REVPAT ]] || exit; export REV=\"\${BASH_REMATCH[1]}\"; $PREVIEW " \
	  --header-first --header "$HEADER" \
	  < <(jj --no-pager --ignore-working-copy log --color=always -T builtin_log_oneline -r "$REVISION" )
     ) &&
    [[ "$REV" =~ $REVPAT ]] &&
    echo "${BASH_REMATCH[1]}" &&
    exit 0
  exit 1
)
FUNCTIONS+=( 'selectchange' )

# Abandon Revision
abandon()
(
  R="$(xrev "${1:-@}")"
  ( set -x
    jj abandon -r "$R" ) ||
    sleep 1
)
KEYBINDINGS["Alt-A"]="abandon"

# Commit (full)
commit()
(
  R="$(xrev "${1:-@}")"
  # Edit commit msg if mutable
  IMMU=$($JJFZFSHOW -r "$R" -T 'if(immutable, "true")')
  [[ $IMMU =~ ^true ]] || {
    O="$(rev_description "$R")"
    MSG="$(echo_commit_msg "$R")"
    user_editor_on_var "COMMIT.txt" MSG ||
      ERROR "Commit cancelled by user"
    # update commit msg if needed
    test "$O" == "$MSG" ||
      jj describe --no-edit -r "$R" -m "$MSG"
  }
  # open new empty working copy commit
  jj new "$R"
)
KEYBINDINGS["Alt-C"]="commit"

# Edit Commit Message
describe()
(
  R="$(xrev "${1:-@}")"
  O="$(rev_description "$R")"
  MSG="$(echo_commit_msg "$R")"
  user_editor_on_var "COMMIT.txt" MSG ||
    ERROR "Describe cancelled by user"
  test "$O" == "$MSG" || {
    jj describe --no-edit -r "$R" -m "$MSG" ||
      sleep 1
  }
)
KEYBINDINGS["Ctrl-E"]="describe"

# Help with JJ commands
help()
(
  JJCMDS=:
  for w in $( LANG=C
	      jj --help |
		sed -r '1,/^Commands:/d; /^\w/{x;q}; s/^ *(\w+)\b.*/\1/' ) ; do
    [[ $w == help ]] && continue
    JJCMDS="$JJCMDS$w:"
  done
  "${FZFPOPUP[@]}" \
    --header-first --no-sort \
    --header "jj --help" \
    --nth 1 \
    --preview "[[ $JJCMDS =~ :{1}: ]] && jj {1} --help" \
    --bind "enter:execute( [[ $JJCMDS =~ :{1}: ]] && { jj {1} --help | $JJFZFPAGER; } )+abort" \
    < <(jj help)
)
KEYBINDINGS["Ctrl-H"]="help"

# Split change
split-interactive()
(
  R="$(xrev "$1")"
  jj split --interactive -r "$R" ||
    sleep 1
)
KEYBINDINGS["Alt-I"]="split-interactive"

# Merge into upstream branch
merge-upstream()
(
  R="$(xrev "${1:-@}")"
  C="$(rev_commitid "$R")"
  BRANCH="$(rev_branches "$R") $C" &&	# pick first branch name or $C
    [[ $BRANCH =~ ([^ ]+) ]] && BRANCH="${BASH_REMATCH[1]}"
  require_git_dir
  # find upstream branch name
  UPSTREAMNAMES="master trunk main" DEST=
  for M in $UPSTREAMNAMES ; do
    test -n "$(git config --get branch.$M.remote)" && DEST="$M" && break
  done		# check tracking branch
  test -n "$DEST" ||
    for M in $UPSTREAMNAMES ; do
      test -n "$(git rev-parse origin/$M $M 2>/dev/null)" && DEST="$M" && break
    done	# check matching remote and local branch
  test -n "$DEST" || ERROR "failed to find upstream merge branch (tried $UPSTREAMNAMES)"
  # check for work in progress
  git --no-pager diff -U0 "$DEST..$BRANCH" |	# examine all branch changes
    egrep "^\+.*\b(XXX|WIP|FIXME)\b" &&		# work still to be done
    WARN="(WARNING: merge diff contains WIP keywords)" || WARN=
  # create merge msg
  TEMPD="`mktemp --tmpdir -d jjfzf0XXXXXX`" || die "mktemp failed"
  trap "rm -rf '$TEMPD'" 0 HUP INT QUIT TRAP USR1 PIPE TERM
  SEP="^^^^^^^^^^^^"
  echo -e "# $SEP DRAFT:  merge $BRANCH into $DEST ${WARN:+$WARN} $SEP # DELETE THIS" > "$TEMPD/MERGE.txt"
  echo -e "Merge branch '$BRANCH'\n\n* Branch commit log:" >> "$TEMPD/MERGE.txt"
  git log --pretty=$'\f%s%+b' "$DEST..$BRANCH" |
    sed '/^\(Signed-off-by\|Acked-by\|Tested-by\|Cc\):/d' |
    sed '/^$/d ; s/^/\t/ ; s/^\t\f/  /' >> "$TEMPD/MERGE.txt"
  echo_signoff >> "$TEMPD/MERGE.txt"
  # edit merge msg
  HO=`md5sum "$TEMPD/MERGE.txt"`
  $EDITOR "$TEMPD/MERGE.txt" &&
    HN=`md5sum "$TEMPD/MERGE.txt"` ||
      HN="$HO"
  test "$HO" != "$HN" ||
    ERROR "Merge cancelled by user"
  # create merge
  jj new --no-edit -m "$(cat "$TEMPD/MERGE.txt")" "$DEST" "$BRANCH" ||
    sleep 1
)
KEYBINDINGS["Alt-M"]="merge-upstream"

# New --insert-before
new-before()
(
  R="$(xrev "${1:-@}")"
  jj new --insert-before "$R" ||
    sleep 1
)
KEYBINDINGS["Alt-N"]="new-before"

# New
new()
(
  R="$(xrev "${1:-@}")"
  jj new "$R" ||
    sleep 1
)
KEYBINDINGS["Ctrl-N"]="new"

# Squash Commits
squash()
(
  R="$(xrev "${1:-@}")"
  test \
    empty-silent == "$($JJTMPL_R "$R"  -T 'separate(" ",if(empty && !description, "empty-silent"))')" -a \
    empty-silent == "$($JJTMPL_R "$R-" -T 'separate(" ",if(empty && !description, "empty-silent"))')" &&
    exec jj abandon -r "$R-"  # squash 2 empty via abandoning parent # FIXME if child is workdir, just edit @-
  jj squash -r "$R" || # --keep-emptied
    sleep 1
)
KEYBINDINGS["Alt-Q"]="squash"

# Rebase Revision/Branch/Descendants
rebase-cmd()
(
  S="$(xrev "$1")"
  M="$2"		# -r -b -s
  WHAT="${3:-BRANCH}"	# REVISION BRANCH SOURCE
  PREVIEW=":"
  PREVIEW="$PREVIEW && echo && echo jj rebase $M $S -d \$REV && echo"
  PREVIEW="$PREVIEW && echo $WHAT: && $JJFZFONELINE -r $S && echo"
  PREVIEW="$PREVIEW && echo DESTINATION: && $JJFZFONELINE -r \$REV && echo"
  PREVIEW="$PREVIEW && echo COMMON: && $JJFZFONELINE -r 'heads( ::$S & ::'\$REV')'"
  D=$( $SELF \
	 selectchange "all: :: ~$S" \
	 'Destination> ' \
	 "$PREVIEW"
   ) || exit
  D="$(rev_changeid "$D")"
  COMMON=$(jj --ignore-working-copy log --no-graph -T 'change_id++" "' -r " heads(::$D & ::$S) ") # maybe >1
  MESSAGE "$WHAT=$S DESTINATION=$D COMMON='$COMMON'"
  # -b skips "$COMMON" == "$D"; but -s will rebase
  ( set -x
    jj rebase $M "$S" -d "$D"
  ) || sleep 1
)

# Rebase Branch
rebase-branch()
(
  rebase-cmd "${1:-@}" -b "BRANCH"
)
KEYBINDINGS["Alt-L"]="rebase-branch"

# Rebase Descendants
rebase-descendants()
(
  rebase-cmd "${1:-@}" -s "SOURCE"
)
KEYBINDINGS["Alt-S"]="rebase-descendants"

# Rebase Revision
rebase-revision()
(
  rebase-cmd "${1:-@}" -r "REVISION"
)
KEYBINDINGS["Alt-R"]="rebase-revision"

# Duplicate Commit
duplicate()
(
  R="$(xrev "${1:-@}")"
  jj duplicate "$R" ||
    sleep 1
)
KEYBINDINGS["Alt-U"]="duplicate"

# Swap Commits
swap-commits()
(
  R="$(xrev "$1")"
  jj rebase -r "$R" --insert-before "$R-"
)
KEYBINDINGS["Alt-X"]="swap-commits"

# Undo last JJ op
undo()
(
  jj op undo
)
KEYBINDINGS["Ctrl-Z"]="undo"

# Edit (New) Working Copy
working-copy()
(
  R="$(xrev "${1:-@}")"
  IMMU=$($JJFZFSHOW -r "$R" -T 'if(immutable, "true")')
  [[ $IMMU =~ ^true ]] && CMD='new' || CMD='edit'
  jj $CMD -r "$R" ||
    sleep 1
)
KEYBINDINGS["Ctrl-W"]="working-copy"

# Show change
show()
(
  R="$(xrev "${1:-@}")"
  ( set -x
    jj show -s --git -r "$R" --color=always ) | $JJFZFPAGER
)
KEYBINDINGS["Ctrl-S"]="show"

# == Function calling ==
[[ "${1:-}" =~ ^[a-z0-9_]+ ]] &&
  [[ " ${KEYBINDINGS[@]} ${FUNCTIONS[@]} " =~ \ $1\  ]] && {
  FUNC="$1" "$@"
  exit $?
}
STARTQUERY="${1:-}"

# == Sync ==
# Synchronize before changes in git or @ mess up state during jj log
jj git import --quiet
jj status >/dev/null
jj git export --quiet

# == Help / Docs ==
HELPKEYS=$(declare -p KEYBINDINGS) && declare -A HELPKEYS="${HELPKEYS#*=}"	# copy KEYBINDINGS -> HELPKEYS
HELPKEYS[Ctrl-↑]='preview-up'
HELPKEYS[Ctrl-↓]='preview-down'
KEYS="${!HELPKEYS[@]}"
KEYS=$(sort <<<"${KEYS// /$'\n'}")
WHITE="                                                                                "
HEADER=""
i=0
for k in $KEYS ; do
  S="$k: ${HELPKEYS[$k]}"	# printf(1) cannot count UTF-8 continuation chars (0x80-0xBF)
  test ${#S} -lt 26 && S="$S${WHITE:0:$(( 26 - ${#S} ))}"	# so, format like %-26s
  HEADER="$HEADER$S" #$HIGH"
  i=$(($i+1))
  test 0 == $(($i % 3)) &&
    HEADER="$HEADER"$'\n' ||
      HEADER="$HEADER "
done

# == FZF ==
RELOAD="reload( exec $SELF loadlog {q} )"
BIND=()
for k in "${!KEYBINDINGS[@]}" ; do
  BIND+=( --bind "${k,,}:execute( $SELF ${KEYBINDINGS[$k]} {} {q} )+$RELOAD+refresh-preview" )
done

fzf \
  "${FZFSETTINGS[@]}" \
  -q "$STARTQUERY" \
  --no-tac --no-sort \
  --disabled +m \
  --header "$HEADER" \
  --bind "change:$RELOAD+refresh-preview" \
  --bind "enter:execute( $SELF show {} {q} )+$RELOAD" \
  "${BIND[@]}" \
  --preview " exec $SELF preview {} {q} " \
  --prompt 'Revset|Regexp> ' \
  < <( $SELF loadlog "$STARTQUERY" ) || :
