#!/bin/bash
# This Source Code Form is licensed MPL-2.0: http://mozilla.org/MPL/2.0
set -Eeuo pipefail #-x
SCRIPTNAME=`basename $0` && function die  { [ -n "$*" ] && echo "$SCRIPTNAME: **ERROR**: ${*:-aborting}" >&2; exit 127 ; }
SELF="$0"

# == PREVIEW fast path ==
export REVPAT='^[^a-z()0-9]*([k-xyz]{7,})([?]*)\ '		# line start, ignore --graph, parse revision letters, catch '??'-postfix
if test -n "${JJFZF_OUTER_TEMPD:-}" -a -n "${JJ_CONFIG:-}" \
	-a "${1:-}" == preview					# preview command, nested invocation
then
  if [[ "${2:-}" =~ $REVPAT ]]					# match beginning of jj log line
  then
    cd "$(jj --ignore-working-copy root)"			# ensure root relative diffstat paths
    REVISION="${BASH_REMATCH[1]}"
    if [[ "${BASH_REMATCH[2]}" == '??' ]]			# divergent change_id
    then
      # https://martinvonz.github.io/jj/latest/FAQ/#how-do-i-deal-with-divergent-changes-after-the-change-id
      jj --no-pager --ignore-working-copy show -T builtin_log_oneline -r "${BASH_REMATCH[1]}" 2>&1 || :
      REVISION=$(echo " $2 " | grep -Po '(?<= )[a-f0-9]{8,}(?= )') || exit 0	# find likely commit id
      echo
      echo
    fi
    if test -e "${JJFZF_OUTER_TEMPD:-}/evolog" 			# display evolog if toggled
    then
      jj --no-pager --ignore-working-copy ${JJFZF_ATOP:+--at-op $JJFZF_ATOP} evolog --color=always -r "$REVISION"
    else							# show commit and diff
      jj --no-pager --ignore-working-copy ${JJFZF_ATOP:+--at-op $JJFZF_ATOP} log --color=always --no-graph -T 'jj_fzf_showdetails' -s -r "$REVISION"
      exec jj --no-pager --ignore-working-copy ${JJFZF_ATOP:+--at-op $JJFZF_ATOP} show --color=always -T ' "\n" ' -r "$REVISION"
    fi
  else								# no valid revision
    true
  fi
  exit 0
fi

# == Check Deps ==
jj --version | grep -Eq 'jj [1-9]\.|jj 0\.2[2-9]\.|jj 0.[3-9][0-9]' || die 'jj-0.22 is required'
fzf --help | grep -Fq ' --header-first' || die 'fzf-0.29 is required'
sed --version | grep -Fq 'GNU sed' || die 'GNU sed is required'

# == Config ==
declare -A DOC
TOMLCFG='revset-aliases.recent7 = " ancestors(heads(mutable()),7) ~ immutable() | immutable_heads() | bookmarks() | remote_bookmarks() "'
# JJ repository
JJROOT=$(jj --ignore-working-copy root) || die "$PWD: not a JJ repository"
JJFZFSHOW="jj --no-pager --ignore-working-copy ${JJFZF_ATOP:+--at-op $JJFZF_ATOP} show --tool true"
JJFZFONELINE="jj --no-pager --ignore-working-copy log --color=always --no-graph -T builtin_log_oneline"
JJFZFPAGER="less -Rc"
JJSUBSHELL='T=$(tty 2>/dev/null||tty <&1 2>/dev/null||tty <&2 2>/dev/null)&&test -n "$T"&&echo -e "\n#\n# Type \"exit\" to leave subshell\n#" && exec /bin/bash -i <$T 1>$T 2>$T'
FZFSETTINGS=(
  --ansi --no-mouse
  --info default
  --layout reverse-list
  --scroll-off 3
  --bind "ctrl-x:jump"
  --bind 'home:first,end:last'
  --bind "ctrl-z:execute( $JJSUBSHELL )"
  --bind='f11:change-preview-window(bottom,75%,border-horizontal|)'
  --preview-window 'wrap,right,border-left'
)
FZFPOPUP=(fzf "${FZFSETTINGS[@]}" --margin 0,2%,5%,2% --border)
JJLOGCMD=( jj --no-pager --ignore-working-copy ${JJFZF_ATOP:+--at-op $JJFZF_ATOP} log --color=always -T jj_fzf_oneline -r '::' )
TEMPD=

# == JJ_CONFIG ==
jj_config() {
  cat <<-__EOF__
	[snapshot]
	# avoid intermediate errors like "<file> is too large to be snapshotted" around JJ-FZF functions
	auto-track = "none()"
	[revset-aliases]
	recent7 = " ancestors(heads(mutable()),7) ~ immutable() | immutable_heads() | bookmarks() | remote_bookmarks() "
	[template-aliases]
	# parsable version of builtin_log_oneline; https://github.com/martinvonz/jj/blob/main/cli/src/config/templates.toml
	jj_fzf_oneline = '''
	if(root,
	  format_root_commit(self),
	  label(if(current_working_copy, "working_copy"),
	    concat(
	      separate(" ",
	        format_short_change_id_with_hidden_and_divergent_info(self),
	        if(author.email(), author.username(), email_placeholder),
	        committer.timestamp().local().format("%Y-%m-%d"),
	        format_short_commit_id(commit_id),
	        bookmarks,
	        tags,
	        working_copies,
	        git_head,
	        if(conflict, label("conflict", "conflict")),
	        if(empty, label("empty", "(empty)")),
	        if(description,
	          description.first_line(),
	          label(if(empty, "empty"), description_placeholder),
	        ),
	      ) ++ "\n",
	    ),
	  )
	)'''
	# extended version of builtin_log_detailed; https://github.com/martinvonz/jj/blob/main/cli/src/config/templates.toml
	jj_fzf_showdetails = '''
	concat(
	  builtin_log_oneline,
	  "Change ID: " ++ self.change_id() ++ "\n",
	  "Commit ID: " ++ commit_id ++ "\n",
	  surround("Refs:      ", "\n", separate(" ", local_bookmarks, remote_bookmarks, tags)),
	  if(immutable, "Immutable: " ++ label("description placeholder", "true") ++ "\n"),
	  "Parents:  " ++ self.parents().map(|c| " " ++ c.change_id()) ++ "\n",
	  "Author:    " ++ format_detailed_signature(author) ++ "\n",
	  "Committer: " ++ format_detailed_signature(committer)  ++ "\n\n",
	  indent("    ",
	    coalesce(description, label(if(empty, "empty"), description_placeholder) ++ "\n")),
	  "\n",
	)'''
	# Provide special oplog marker that can be parsed for undone operations
	builtin_op_log_node = '''
	coalesce(
	  if(current_operation, label("current_operation", "@")), "○",
	)'''
	# Oneline oplog with 16 character ids, parsed later on; https://github.com/martinvonz/jj/blob/main/cli/src/config/templates.toml
	jj_fzf_oplog_oneline = '''
	label(if(current_operation, "current_operation"),
	  coalesce(
	    if(root, format_root_operation(self)),
	    concat(
	      separate(" ", self.id().short(16), self.user(), self.time().start().ago()), " ",
	      self.description().first_line(), " ",
	      if(self.tags(), self.tags().first_line()),
	    )
	  )
	)'''
	# Adjust colors for FZF display
	[colors]
	# "node working_copy" = { fg = "red", bold = true }
	"empty" = "blue"
	"empty description placeholder" = "blue"
	"description placeholder" = "blue"
	"working_copy empty" = "blue"
	"working_copy empty description placeholder" = "blue"
	"working_copy description placeholder" = "blue"
	bookmarks =  "bright green"
	tags = { fg = "yellow", bold = true }
	"diff removed token" = { underline = false }
	"diff added token" = { underline = false }
	__EOF__
}

# == Utils ==
# Create temporary dir, assigns $TEMPD
temp_dir()
{
  test -n "$TEMPD" || {
    TEMPD="`mktemp --tmpdir -d jjfzf0XXXXXX`" || die "mktemp failed"
    trap "rm -rf '$TEMPD'" 0 HUP INT QUIT TRAP USR1 PIPE TERM
    echo "$$" > $TEMPD/jj-fzf.pid
  }
}
# Match JJ revision as first ASCII word (e.g. as in builtin_log_oneline)
export REVPAT='^[^a-z()0-9]*([k-xyz]{7,})([?]*)\ '
export OPPAT='^[^a-z()0-9]*([0-9a-f]{9,})\ '
# Extract JJ revision from first word
xrev()
(
  if [[ "$* " =~ $REVPAT ]] ; then      # jj log line
    if [[ "${BASH_REMATCH[2]}" == '??' ]] ; then   # https://martinvonz.github.io/jj/latest/FAQ/#how-do-i-deal-with-divergent-changes-after-the-change-id
      echo "${BASH_REMATCH[1]}${BASH_REMATCH[2]}"
      false
    else
      rev_changeid "${BASH_REMATCH[1]}"
    fi
  elif [[ "$*" =~ ^([^\ ]+)$ ]] ; then	# revision identifier w/o whitespace
    rev_changeid "${BASH_REMATCH[1]}"
  fi
)
# Look up full revision via JJ change_id
rev_changeid()	( $JJFZFSHOW -T 'change_id' -r "$1" )
# Look up full commit hash via JJ commit_id
rev_commitid()	( $JJFZFSHOW -T 'commit_id' -r "$1" )
# parse commit_id of given divergent change_id or return ""
divergent_commitid()
(
  DIVERGENT_REVISION_COMMIT=' format_short_change_id_with_hidden_and_divergent_info(self) ++ " " ++ commit_id ++ "\n" '
  # make sure it is a divergent commit id
  COMMIT=$(jj --ignore-working-copy log --no-graph -T "$DIVERGENT_REVISION_COMMIT" -r "$1" | grep -Po '(?<=\?\? )[a-f0-9]{8,}\b') &&
    echo "$COMMIT"
)
# Yield the revision change_id or a commit_id if it is divergent
xrev_or_commit()
(
  if R="$(xrev "$*")" ; then
    echo "$R"
  else
    # extract likely commit ID from divergent revision
    COMMIT=$(echo " $* " | grep -Po '(?<= )[a-f0-9]{8,}(?= )') && {
      # validates commit of divergent change
      divergent_commitid "$COMMIT"
    }
  fi
)
# List all bookmarks of a revision
rev_bookmarks()	( $JJFZFSHOW -T 'concat(separate(" ",bookmarks))' -r "$1" )
# Get revision description
rev_description() ( $JJFZFSHOW -T 'concat(description)' -r "$1" )

# Condense commit empty/description/parent state into a key word
rev_edpstate()
(
  export EDPSTATE='separate("-", if(empty, "empty", "diff"), if(description, "description", "silent"), "p" ++ self.parents().len()) ++ "\n"'
  $JJFZFSHOW -r "$1" -T "$EDPSTATE" # empty-description-p2 diff-silent-p1 etc
)

# List children of a revision
rev_children()
(
  jj --no-pager --ignore-working-copy log --no-graph -r "all: $1+" -T 'change_id++"\n"'
)

# reverse_array ORIG REVERSED - copy the elements from ORIG in REVERSED in reverse order
reverse_array()
{
  local -n array_O_=$1
  local -n array_R_=$2
  # Loop in reverse order
  for ((i=${#array_O_[@]}-1; i>=0; i--)); do
    array_R_+=("${array_O_[i]}")
  done
}

# diff_arrays BEFORE AFTER RESULT - store the elements from AFTER without elements from BEFORE in RESULT
diff_arrays()
{
  local -n array_O_=$1
  local -n array_N_=$2
  local -n array_R_=$3
  declare -A counts_
  # Mark elements in A
  for elem in "${array_O_[@]}" ; do
    counts_["$elem"]=1
  done
  # Add all of B to C if not in A
  for elem in "${array_N_[@]}"; do
    test -z "${counts_[$elem]:-}" &&
      array_R_+=("$elem") # || echo "SKIP: $elem : ${counts_[$elem]:-}"
  done
  true
}

# Require .git directory and set GIT_DIR
require_git_dir()
{
  test -e "$JJROOT/.git" &&
    export GIT_DIR="$JJROOT/.git" || {
      test -e "$JJROOT/.jj/repo/store/git" &&
	export GIT_DIR="$JJROOT/.jj/repo/store/git" ||
	  die "$PWD: failed to find .git store"
    }
}
ERROR()
{
  FUNC="${FUNC:-$0}"
  echo "ERROR: ${FUNC:+$FUNC:}" "$*" >&2
  read -t 2
  exit
}

# == Helpers ==
# Echo signoff
echo_signoff()
(
  JJFZF_SIGNOFF=true	# config get jjfzf.signoff
  if test "${JJFZF_SIGNOFF:-true}" == true ; then
    echo # separating newline before signoff section
    $JJFZFSHOW -T 'format_detailed_signature(author) ++ "\n"' -r @ |
      sed -e 's/>.*/>/ ; s/^/Signed-off-by: /'
  fi
)
# Echo current or default message
echo_commit_msg()
(
  R="$1"
  S=$(rev_edpstate "$R")
  # keep existing message
  [[ $S =~ -silent- ]] || {
    rev_description "$R"
    return
  }
  # start with file name prefixes
  cd "$JJROOT" # create root relative file names
  FILES=()
  readarray -t FILES < <(jj log --no-graph -r "$R" -T '' -s | sed 's/^\w //')
  test ${#FILES[@]} -gt 0 &&
    printf "%s: \n" "${FILES[@]}" ||
      echo ""
  # ensure signoff
  echo_signoff
)
# Run user editor: user_editor_on_var <FILE> <VARIABLE>
user_editor_on_var()
{
  local FILE="$1" N=
  declare -n _ueovMSG="$2"			# <VARIABLE> alias
  # create msg file
  temp_dir
  local TEMPFILE="$TEMPD/$FILE"
  cat >"$TEMPFILE" <<<"$_ueovMSG"
  # edit commit msg
  $EDITOR "$TEMPFILE" &&
    N="$(cat "$TEMPFILE")" && {
      test "$_ueovMSG" != "$N" &&
	_ueovMSG="$(cat "$TEMPFILE")"
      rm -f "$TEMPFILE"
      return 0
    }
  rm -f "$TEMPFILE"
  return 1
}

# == Functions ==
FUNCTIONS=()
declare -A KEYBINDINGS
FIRSTS=""
NEXTS=""

# Toggle preview of evolution-log
DOC['toggle-evolog']='Toggle the preview between `jj evolution-log` and *change_id* diff view.'
toggle-evolog()
{
  if test -n "${JJFZF_OUTER_TEMPD:-}" ; then
    if test -e "${JJFZF_OUTER_TEMPD:-}/evolog" ; then
      rm -f "${JJFZF_OUTER_TEMPD:-}/evolog"
    else
      touch "${JJFZF_OUTER_TEMPD:-}/evolog"
    fi
  fi
}
KEYBINDINGS["Ctrl-T"]="toggle-evolog"

# Abandon Revision
DOC['abandon']='Use `jj abandon` to remove the currently selected revision (or divergent commit) from the history.'
abandon()
(
  R="$(xrev_or_commit "${1:-@}")" ||
    die "no such revision"
  ( set -x
    jj abandon -r "$R" ) ||
    sleep 1
)
KEYBINDINGS["Alt-A"]="abandon"

# Bookmark Creation
DOC['bookmark']='Use `jj bookmark {create|set -B}` to (re-)assign a bookmark name to the currently selected revision.'
bookmark()
(
  R="$(xrev "${1:-@}")"
  read -p 'Bookmark Name: ' B &&
    test -n "$B" ||
      return
  set +o pipefail &&
    jj --ignore-working-copy bookmark list "$B" 2>/dev/null |
      grep -qF "$B" &&
    S='set -B' || S='create'
  ( set -x
    jj bookmark $S "$B" -r "$R"
  ) && jj git export --quiet ||
      sleep 1
)
KEYBINDINGS["Alt-B"]="bookmark"

# Commit (full)
DOC['commit']='Use `jj commit` to describe the currently selected revision and create a new child revision as working-copy.'
commit()
(
  R="$(xrev "${1:-@}")"
  W="$(xrev "@")"
  IMMU=$($JJFZFSHOW -r "$R" -T 'if(immutable, "true")')
  MSG="$(echo_commit_msg "$R")"
  O="$MSG"
  if test "$R" == "$W" -a "$IMMU" != true ; then
    user_editor_on_var "COMMIT-$R.txt" MSG &&
      test "$O" != "$MSG" ||
	ERROR "Commit cancelled by user"
      ( set -x
	jj commit -m "$MSG"
      ) || sleep 1
  else # R is @ and mutable
    [[ $IMMU =~ ^true ]] || {
      user_editor_on_var "COMMIT-$R.txt" MSG &&
	test "$O" != "$MSG" ||
	  ERROR "Commit cancelled by user"
      test "$O" != "$MSG" &&
	( set -x
	  jj describe --no-edit -r "$R" -m "$MSG"
	) || sleep 1
    }
    # open new empty working copy commit
    jj new "$R"
  fi
)
KEYBINDINGS["Alt-C"]="commit"		FIRSTS="$FIRSTS commit"

# Delete Bookmarks and Tags
DOC['delete-refs']='Use `jj bookmark list+delete` to list, selected and delete bookmarks and tags.'
delete-refs()
(
  R="$(xrev "${1:-@}")"
  require_git_dir
  jj git export --quiet
  jj git import --quiet
  # Find Bookmark on @ for initial query
  B=$($JJFZFSHOW -r "$R" -T 'concat(separate(" ",bookmarks))') &&
    B="${B%% *}" &&
    test -n "$B" &&
    B=(-q "$B") ||
      B=()
  DEL=$("${FZFPOPUP[@]}" \
  	  --prompt "Delete > " \
	  --header $'\n'"Delete selected Bookmark or Tag" --header-first \
	  --no-tac --no-sort +m \
	  -d: --nth 1 "${B[@]}" \
	  < <(
	  (
	    jj bookmark list | while read n rest ; do
	      printf "%-28s (bookmark) %s\n" "$n" "$rest"
	    done
	    echo
	    git tag -n1 | while read n rest ; do
	      printf "%-28s (tag) %s\n" "$n:" "$rest"
	    done
	  )
	)
     )
  DEL="${DEL%%:*}" # strip :...
  test -n "$DEL" || return
  (
    jj bookmark list | fgrep -q "$DEL:" ;
    echo "bookmark list check: $?"
    if set +o pipefail && jj --ignore-working-copy bookmark list | fgrep -q "$DEL:" ; then
      ( set -x
	jj bookmark delete $DEL )
      jj git export --quiet
    else
      ( set -x
	git tag -d "$DEL" )
      jj git import --quiet
    fi
  ) ||
    sleep 1
)
KEYBINDINGS["Alt-D"]="delete-refs"

# diffedit
DOC['diffedit']='Use `jj diffedit` to modify the content diff of the currently selected revision.'
diffedit()
(
  R="$(xrev "${1:-@}")"
  jj diffedit -r "$R"
)
KEYBINDINGS["Alt-E"]="diffedit"

# Reset commit author
DOC['author-reset']='Use `jj describe --reset-author` to reset the author and email of the currently selected revision.'
author-reset()
(
  R="$(xrev "${1:-@}")"
  ( set -x
    jj describe --reset-author --no-edit -r "$R"
  ) ||
    sleep 1
)
KEYBINDINGS["Ctrl-A"]="author-reset"

# Describe Commit Message
DOC['describe']='Use `jj describe` to describe the currently selected revision.'
describe()
(
  R="$(xrev "${1:-@}")"
  MSG="$(echo_commit_msg "$R")"
  O="$MSG"
  user_editor_on_var "CHANGE-$R.txt" MSG ||
    ERROR "Describe cancelled by user"
  test "$O" != "$MSG" && (
    set -x
    jj describe --no-edit -r "$R" -m "$MSG"
  ) ||
    sleep 1
)
KEYBINDINGS["Ctrl-D"]="describe"

# File Editor
DOC['file-editor']='Use `jj edit` to switch to the currently selected revision and opens the files touched by this revision in `$EDITOR`.'
file-editor()
(
  R="$(xrev "${1:-@}")"
  W="$(xrev "@")"
  # cd root; otherwise revision file paths will mismatch
  cd "$JJROOT"
  # read files edited by revision
  readarray -t FILES < <(jj log --no-graph -r "$R" -T '' -s | sed 's/^\w //')
  # make sure to edit revision
  test "$W" == "$R" || (
    IMMU=$($JJFZFSHOW -r "$R" -T 'if(immutable, "true")')
    [[ $IMMU =~ ^true ]] && CMD='new' || CMD='edit'
    set -x
    jj $CMD -r "$R"
  )
  ( set -x
    ${EDITOR:-nano} "${FILES[@]}"
  )
)
KEYBINDINGS["Ctrl-F"]="file-editor"

# Help with JJ commands
DOC['help']='Show the *jj-fzf* help or browse the help descriptions of the currently seleected *jj* command in the `jj help` text.'
help()
(
  H=$'JJ-FZF\n'
  H="$H"$'\n'
  H="$H"$'JJ-FZF is an FZF based wrapper around the Jujutsu VCS.\n'
  H="$H"$'FZF is the fuzzy file browser that provides line based selections and preview.\n'
  H="$H"$'\n'
  JJCMDS=:
  for w in $( LANG=C
	      jj --help |
		sed -r '1,/^Commands:/d; /^\w/{x;q}; s/^ *(\w+)\b.*/\1/' ) ; do
    [[ $w == help ]] && continue
    JJCMDS="$JJCMDS$w:"
  done
  "${FZFPOPUP[@]}" \
    --header-first --no-sort \
    --header "jj --help" \
    --nth 1 \
    --preview "[[ $JJCMDS =~ :{1}: ]] && jj {1} --help || $SELF --help --color" \
    --bind "enter:execute( test -n {1} || exit; { [[ $JJCMDS =~ :{1}: ]] && jj {1} --help || jj help ;} | $JJFZFPAGER )+abort" \
    < <(echo "$H" && jj --color=always help)
)
KEYBINDINGS["Ctrl-H"]="help"

# Split change
DOC['split-interactive']='Use `jj split` to interactively select content diff hunks to be split into a new commit. No text editor is invoked and the new commit gets an empty description.'
split-interactive()
(
  R="$(xrev "$1")"
  # Use $EDITOR to implement --split-with-no-description, truncate the first
  # (original) description, but keep the description for subsequent edits
  temp_dir
  cat > $TEMPD/trunc1st.sh <<-\__EOF__
	#!/bin/bash
	set -Eeuo pipefail #-x
	TRUNCATE=y
	test $TRUNCATE == y && echo -n > "$1" || :
	sed 's/TRUNCATE=./TRUNCATE=n/' -i "$0"
	__EOF__
  chmod +x $TEMPD/trunc1st.sh
  export EDITOR=$TEMPD/trunc1st.sh
  ( set -x
    jj split --interactive -r "$R"
  ) || sleep 1
)
KEYBINDINGS["Alt-I"]="split-interactive"

# Backout Commit
DOC['backout']='Use `jj backout` to create a new commit that undoes the changes made by the currently selected revision and apply the changes on top of the working-copy.'
backout()
(
  R="$(xrev "${1:-@}")"
  # use working copy as destination, unless it is empty
  test $(rev_edpstate @) == empty-silent-p1 &&
    D=@- ||
      D=@
  # record working-copy and children before/after, then backout
  A=( $(rev_children "$D") )
  ( set -x
    jj backout -r "$R" -d "$D"
  ) || die
  B=( $(rev_children "$D") )
  C=() && diff_arrays A B C
  [ ${#C[@]} -eq 1 ] ||
    die "failed to find newly created backout revision"
  ( set -x
    jj new "${C[0]}"
  ) || die
)
KEYBINDINGS["Alt-K"]="backout"		FIRSTS="$FIRSTS backout"

# Line History
DOC['line-history']='WIP: View history of each line.'
line-history()
(
  R="$(xrev "${1:-@}")"
  C="$(rev_commitid "$R")"
  cd "$JJROOT"	# needed for correct file paths
  require_git_dir
  set +o pipefail
  jj file list -r "$R" |
    xargs grep -s -n '' |
    "${FZFPOPUP[@]}" \
      --preview " git log --no-patch -M -C --find-copies-harder --pretty='%C(blue)%h %C(yellow)%aL %C(reset)%s%n%b' -L{2}:{1} --color $C | sed 's/Signed-off-by:.*//; /^ *$/d' " \
      --bind "enter:execute( git log -M -C --find-copies-harder -L{2}:{1} --color $C | $JJFZFPAGER)" \
      --header "File Line History" \
      --no-tac --no-sort +m -d:
)
KEYBINDINGS["Alt-L"]="line-history"

# Merge into tracked bookmark
DOC['merging']='Start a dialog to select parents for a new merge commit, using `jj new REVISIONS...`. For exactly two parents, a default commit message is suggested. Commits with no description are ignored.'
merging()
(
  P="$(xrev "${1:-@}")"
  cd "$JJROOT" # otherwise, a subdir and $PWD could vanish
  temp_dir
  # Find tracked upstream revision
  [[ $(jj bookmark list -t) =~ ^([^\ :]+): ]] &&
    UPSTREAM="${BASH_REMATCH[1]}" || UPSTREAM=
  echo 0 > $TEMPD/upstream.toggle
  export JJFZFONELINE REVPAT TEMPD UPSTREAM P
  # Parse jj log lines into merging.revs
  merging_revs()
  (
    declare -A counts_
    echo -n > $TEMPD/merging.revs
    test "$(cat $TEMPD/upstream.toggle)" -eq 1 -a -n "$UPSTREAM" &&
      R=$(jj --no-pager --ignore-working-copy show --tool true -r "$UPSTREAM" -T 'if(description, change_id)') &&
      test -n "$R" && {
	echo "$UPSTREAM" >> $TEMPD/merging.revs
	counts_["$R"]=1	# use change_id for deduplication
      }
    LINES=("$@") && REVERSED=() && reverse_array LINES REVERSED
    for ARG in ". $P " "${REVERSED[@]}" ; do
      [[ "$ARG" =~ $REVPAT ]] || continue
      R=$(jj --no-pager --ignore-working-copy show --tool true -r "${BASH_REMATCH[1]}" -T 'if(description, change_id)')
      test -n "$R" && test -z "${counts_[$R]:-}" || continue
      echo "$R" >> $TEMPD/merging.revs
      counts_["$R"]=1
    done
  )
  # Preview merge command for merging.revs
  merging_preview()
  (
    echo && echo jj new `cat $TEMPD/merging.revs` && echo
    test "$(cat $TEMPD/upstream.toggle)" -eq 1 &&
      echo "Upstream: $UPSTREAM" ||
	echo ''
    echo && echo 'Parents:'
    while read R ; do
      $JJFZFONELINE -r "$R"
    done < $TEMPD/merging.revs
  )
  # Provide functions for FZF
  export -f merging_revs merging_preview reverse_array
  # FZF popup to select parent list
  H=$'\n'
  H="$H""Alt-U: Toggle merging into Upstream bookmark"$'\n'
  export FZF_DEFAULT_COMMAND="${JJLOGCMD[@]@Q}"
  "${FZFPOPUP[@]}" \
	  --preview "merging_revs {+} && merging_preview" \
	  --prompt "Merge +> " \
	  --header "$H" --header-first \
	  --bind "alt-u:execute( sed 's/0/2/;s/1/0/;s/2/1/' -i $TEMPD/upstream.toggle )+refresh-preview" \
	  --no-tac --no-sort -m > $TEMPD/selections.txt &&
    mapfile -t selections < $TEMPD/selections.txt &&
    merging_revs "${selections[@]}" &&
    mapfile -t REVS < $TEMPD/merging.revs &&
    test "${#REVS[@]}" -gt 0 ||
      exit # Merge cancelled
  # Create merge message
  JJNEW_ARGS=("${REVS[@]}")
  test "${#REVS[@]}" -eq 2 && {
    MSG=$( SEP="^^^^^^^^^"
	   echo -e "# $SEP DRAFT:  merge ${REVS[1]} into ${REVS[0]}" \
		"${WARN:+$WARN}" "$SEP # DELETE THIS"
	   echo -e "Merge branch '${REVS[1]}'\n\n* Branch commit log:"
	   git log --pretty=$'\f%s%+b' $(rev_commitid "${REVS[0]}")...$(rev_commitid "${REVS[1]}") |
	     sed '/^\(Signed-off-by\|Acked-by\|Tested-by\|Cc\):/d' |
	     sed '/^$/d ; s/^/\t/ ; s/^\t\f/  /'
	   echo_signoff
       )
    # edit merge msg
    O="$MSG"
    user_editor_on_var "MERGE-MSG.txt" MSG &&
      test "$O" != "$MSG" ||
	ERROR "Merge commit cancelled by user"
    JJNEW_ARGS+=(-m "$MSG")
  }
  # Merge revisions
  ( set -x
    jj new "${JJNEW_ARGS[@]}"
  ) && {
    test "$(cat $TEMPD/upstream.toggle)" -ne 1 ||
      ( set -x
	jj bookmark set -B -r @ "$UPSTREAM" )
  } || sleep 1
)
KEYBINDINGS["Alt-M"]="merging"		FIRSTS="$FIRSTS merging"

# New --insert-before
DOC['new-before']='Use `jj new --insert-before` to create and insert a new revision before the currently selected revision (or divergent commit).'
new-before()
(
  R="$(xrev_or_commit "${1:-@}")" ||
    die "no such revision"
  ( set -x
    jj new --insert-before "$R"
  ) || sleep 1
)
KEYBINDINGS["Alt-N"]="new-before"

# New
DOC['new']='Use `jj new` to create a new revision on top of the currently selected revision (or divergent commit).'
new()
(
  R="$(xrev_or_commit "${1:-@}")" ||
    die "no such revision"
  ( set -x
    jj new "$R"
  ) || sleep 1
)
KEYBINDINGS["Ctrl-N"]="new"		FIRSTS="$FIRSTS new"

# Log undone operations
undone_log()
(
  # list all oplog descriptions, find description with "undo operation 123abc"
  T='coalesce( self.description().first_line(), " ") ++ "\n"'
  jj --no-pager --ignore-working-copy op log --no-graph --color=never -T "$T" |
    sed -nr '
    	# turn "undo operation 123abc" into an exact id with 16 characters
	/^undo operation [a-f0-9]{16}/s/^undo operation ([a-f0-9]{16}).*/\1/
	T;	# goto EOS unless the previous s/// matched
	P;	# print line replaced by s///
  '
)
FUNCTIONS+=( 'undone_log' )

# Show `jj op log` but mark undone operations with '-'
oplog_oneline()
(
  temp_dir
  # turn each undone and undo operation on "123abc" into a new sed commands that replaces this operations graph character
  undone_log |
    sed -r 's/([a-f0-9]+)/	s|○(.*\1)|-\\1|		/' > $TEMPD/undone.sed
  # show operation log, filtered through the above sed script to alter markers for undone ops
  jj --no-pager --ignore-working-copy op log --color=always -T jj_fzf_oplog_oneline |
    sed -rf $TEMPD/undone.sed	# beware, script needs to ignore ANSI color escape sequences
)
FUNCTIONS+=( 'oplog_oneline' )

# Oplog
DOC['op-log']='Use `jj op log` to browse the recent operations log. Use hotkeys to change the preview between diff, history and oplog entry mode. Undo the selected operation or restore its working copy into a new commit.'
op-log()
(
  RELOAD="reload( exec jj op log --color=always )"
  temp_dir
  echo > $TEMPD/oplog.env
  H=$'\n'
  H="$H""Ctrl-D: Preview diff of '@' at a specific operation"$'\n'
  H="$H""Ctrl-L: Preview history at a specific operation"$'\n'
  H="$H"$'\n'
  H="$H""Alt-W: Restore working copy of the selected operation into a new commit"$'\n'
  H="$H""Alt-Z: Undo the selected operation entry"$'\n'
  echo 'VIEW=log@oplog'		>> $TEMPD/oplog.env
  export FZF_DEFAULT_COMMAND="$SELF oplog_oneline"
  "${FZFPOPUP[@]}" \
    --preview "[[ {} =~ $OPPAT ]] || exit; export JJFZF_ATOP=\"\${BASH_REMATCH[1]}\" && . $TEMPD/oplog.env && $SELF \$VIEW {q}" \
    --prompt "Operation > " \
    --header "$H" --header-first \
    --bind "ctrl-d:execute( sed 's/^VIEW=.*/VIEW=diff@oplog/' -i $TEMPD/oplog.env )+refresh-preview" \
    --bind "ctrl-l:execute( sed 's/^VIEW=.*/VIEW=log@oplog/' -i $TEMPD/oplog.env )+refresh-preview" \
    --bind "alt-w:execute( $SELF wdrestore@oplog {} )+abort" \
    --bind "alt-z:execute( $SELF undo-op@oplog {} )+abort" \
    --bind "enter:execute( [[ {} =~ \$OPPAT ]] || exit && export JJFZF_ATOP=\"\${BASH_REMATCH[1]}\" && $SELF logrev @ {q} )" \
    --no-tac --no-sort +m
)
KEYBINDINGS["Ctrl-O"]="op-log"

log@oplog()
(
  jj --no-pager --ignore-working-copy ${JJFZF_ATOP:+--at-op $JJFZF_ATOP} op log --color=always -T builtin_op_log_comfortable -n 1 --no-graph
  jj --no-pager --ignore-working-copy ${JJFZF_ATOP:+--at-op $JJFZF_ATOP} log --color=always -r '::' -T jj_fzf_oneline # builtin_log_oneline
)
FUNCTIONS+=( 'log@oplog' )

diff@oplog()
(
  jj --no-pager --ignore-working-copy ${JJFZF_ATOP:+--at-op $JJFZF_ATOP} op log --color=always -T builtin_op_log_comfortable -n 1 --no-graph
  if tty -s ; then
    { jj --no-pager --ignore-working-copy ${JJFZF_ATOP:+--at-op $JJFZF_ATOP} log --color=always --no-graph -T "builtin_log_oneline" -s -r "@"
      jj --no-pager --ignore-working-copy ${JJFZF_ATOP:+--at-op $JJFZF_ATOP} show --color=always -T ' "\n" ' -r "@"
    } | $JJFZFPAGER
  else
    jj --no-pager --ignore-working-copy ${JJFZF_ATOP:+--at-op $JJFZF_ATOP} log --color=always --no-graph -T "builtin_log_oneline" -s -r "@"
    jj --no-pager --ignore-working-copy ${JJFZF_ATOP:+--at-op $JJFZF_ATOP} show --color=always -T ' "\n" ' -r "@"
  fi
)
FUNCTIONS+=( 'diff@oplog' )

undo-op@oplog()
(
  [[ "$*" =~ $OPPAT ]] && OP="${BASH_REMATCH[1]}" || return
  C="$(jj --no-pager --ignore-working-copy --at-op $OP show --tool true -T commit_id -r @)"
  ( set -x
    jj op undo $OP
  ) ||
    sleep 1
)
FUNCTIONS+=( 'undo-op@oplog' )

wdrestore@oplog()
(
  set -x
  [[ "$*" =~ $OPPAT ]] && OP="${BASH_REMATCH[1]}" || return
  C="$(jj --no-pager --ignore-working-copy --at-op $OP show --tool true -T commit_id -r @)"
  ( set -x
    jj new @
    jj restore --from "$C" --to @
  ) ||
    sleep 1
)
FUNCTIONS+=( 'wdrestore@oplog' )

# Split files
DOC['split-files']='Use `jj split` in a loop to split each file modified by the currently selected revision into its own commit.'
split-files()
(
  R="$(xrev "$1")"
  # save @
  AT="$(rev_changeid @)"
  # show undo hints
  jj op log -n1
  echo "# jj op restore $(jj op log -n1 --no-graph -T 'self.id().short()') # <- command to undo the following split"
  # adjust working copy, so 'jj split' resulting change_id is predictable
  test "$R" == "$AT" || (set -x; jj edit -r "$R")
  # split for n-1 files
  R1=true # skip first split, need n-1 splits for n files
  F=$(jj show --tool true -s -T '' -r @)
  while read M F ; do
    $R1 && { R1=false; continue; }
    ( export EDITOR=/usr/bin/true
      set -x
      jj split -r @ -- "$F"
    )
  done <<<"$F"
  # restore working copy
  test "$R" == "$AT" || {
    EXISTS=$($JJFZFSHOW -r "$AT" -T '"true"' 2>/dev/null) # squash might have killed an empty commit
    if [[ $EXISTS =~ ^true ]] ; then
      (set -x; jj edit -r "$AT")
    else
      (set -x; jj new -r "@")
    fi
  }
)
KEYBINDINGS["Alt-F"]="split-files"

# Fetch and push to remote Git repositories
DOC['push-remote']='Use `jj git fetch --all-remotes` and `jj git push --tracked` to update the local and remote repositories. Pushing needs confirmation after a dry-run.'
push-remote()
(
  ( set -x
    jj git fetch --all-remotes
    jj git push --tracked --dry-run
  ) || die
  read -p 'Really push to remote? ' YN
  [[ "${YN:0:1}" =~ [yY] ]] && {
    ( set -x
      jj git push --tracked
    ) || die
  }
)
KEYBINDINGS["Ctrl-P"]="push-remote"

# Squash Into Parent
DOC['squash-into-parent']='Use `jj squash` to move the changes from the currently selected revision into its parent.'
squash-into-parent()
(
  R="$(xrev "${1:-@}")"
  W="$(xrev "@")"
  test "$W" == "$R" &&
    OPT='--keep-emptied' || # preserve workspace change_id
      OPT=
  # export EDITOR=true
  ( set -x
    jj squash -r "$R" $OPT # --use-destination-message
  ) ||
    sleep 1
)
KEYBINDINGS["Alt-Q"]="squash-into-parent"

# Squash @ Commit
DOC['squash-@-into']='Use `jj squash` to move the changes from the working copy into the currently selected revision.'
squash-@-into()
(
  R="$(xrev "${1:-@}")"
  ( set -x
    jj squash --keep-emptied --into "$R" # --use-destination-message
  ) ||
    sleep 1
)
KEYBINDINGS["Alt-W"]="squash-@-into"

# Rebase Branch/Source/Revision After/Before/Destination
DOC['rebasing']='Start a dialog to configure the use of `jj rebase` to rebase a branch, source, or revision onto, before or after another revision.'
rebasing()
(
  S="$(xrev "$1")"
  temp_dir
  echo > $TEMPD/rebasing.env
  echo 'FR=--branch'		>> $TEMPD/rebasing.env
  echo 'TO=--destination'	>> $TEMPD/rebasing.env
  export JJFZFONELINE
  PREVIEW=". $TEMPD/rebasing.env"
  PREVIEW="$PREVIEW"' && echo && echo jj rebase $FR '$S' $TO $REV && echo'
  PREVIEW="$PREVIEW"' && F=${FR#--} && echo ${F^^}: && $JJFZFONELINE -r '$S' && echo'
  PREVIEW="$PREVIEW"' && T=${TO#--} && echo ${T^^}: && $JJFZFONELINE -r $REV && echo'
  PREVIEW="$PREVIEW"' && echo COMMON: && $JJFZFONELINE -r "heads( ::'$S' & ::$REV)"'
  H=$'\n'
  H="$H""Alt-B: BRANCH   - Rebase the whole branch relative to destination's ancestors"$'\n'
  H="$H""Alt-S: SOURCE   - Rebase specified revision together with descendants"$'\n'
  H="$H""Alt-R: REVISION - Rebase only given revision, moves descendants onto parent"$'\n'
  H="$H"$'\n'
  H="$H""Alt-D: DESTINATION - The revision to rebase onto"$'\n'
  H="$H""Alt-A: AFTER       - The revision to insert after"$'\n'
  H="$H""Alt-E: BEFORE      - The revision to insert before"$'\n'
  export FZF_DEFAULT_COMMAND="${JJLOGCMD[@]@Q}"
  REV=$("${FZFPOPUP[@]}" \
	  --preview "[[ {} =~ $REVPAT ]] || exit; export REV=\"\${BASH_REMATCH[1]}\"; $PREVIEW " \
	  --prompt "Rebase > " \
	  --header "$H" --header-first \
	  --bind "alt-b:execute( sed 's/^FR=.*/FR=--branch/' -i $TEMPD/rebasing.env )+refresh-preview" \
	  --bind "alt-s:execute( sed 's/^FR=.*/FR=--source/' -i $TEMPD/rebasing.env )+refresh-preview" \
	  --bind "alt-r:execute( sed 's/^FR=.*/FR=--revisions/' -i $TEMPD/rebasing.env )+refresh-preview" \
	  --bind "alt-d:execute( sed 's/^TO=.*/TO=--destination/' -i $TEMPD/rebasing.env )+refresh-preview" \
	  --bind "alt-a:execute( sed 's/^TO=.*/TO=--insert-after/' -i $TEMPD/rebasing.env )+refresh-preview" \
	  --bind "alt-e:execute( sed 's/^TO=.*/TO=--insert-before/' -i $TEMPD/rebasing.env )+refresh-preview" \
	  --no-tac --no-sort +m ) &&
    [[ "$REV" =~ $REVPAT ]] &&
    REV="${BASH_REMATCH[1]}" ||
      REV=
  test -n "$REV" || exit 0
  REV="$(rev_changeid "$REV")"
  . $TEMPD/rebasing.env
  rm -f TEMPD/rebasing.env
  ( set -x
    jj rebase $FR "$S" $TO "$REV"
  ) || sleep 1
)
KEYBINDINGS["Alt-R"]="rebasing"

# Restore File
DOC['restore-file']='Start a dialog to select a file from the currently selected revision and use `jj restore` to restore the file into the working copy.'
restore-file()
(
  R="$(xrev "${1:-@}")"
  MODE_FILE=$(jj show --tool true -T '' -s -r "$R" |
		"${FZFPOPUP[@]}" \
		  --preview 'read M F <<<{} && test -n \"$F\" || exit; jj --no-pager --ignore-working-copy log --color=always -s --patch -T builtin_log_oneline -r "'"$R"'" -- "$F"' \
		  --header "Restore File into @" \
		  )
  read M F <<<"$MODE_FILE"
  test -n "$M" -a -n "$F" || return
  ( set -x
    jj restore --from "$R" -- "$F"
  ) ||
    sleep 1
)
KEYBINDINGS["Alt-S"]="restore-file"

# Tag Creation
DOC['tag']='Enter a tag name to create a new unsigned, annotated tag at the selected revision with `git tag`.'
tag()
(
  R="$(xrev "${1:-@}")"
  C="$(rev_commitid "$R")"
  require_git_dir
  read -p 'Tag Name: ' B &&
    test -n "$B" ||
      return
  M="$(git log -1 --oneline "$C")"
  ( set -x
    git tag -a "$B" -m "$M" "$C"
  ) &&
    jj git import --quiet ||
      sleep 1
)
KEYBINDINGS["Alt-T"]="tag"

# Log single change
logrev()
(
  R="$(xrev_or_commit "${1:-@}")" ||
    die "no such revision"
  cd "$JJROOT" # show root relative file names
  test "${2:-}" = "--all" && R="::$R"
  E=$'\e\[[0-9;,]*m'	# \e[1;2m - match ANSI escape sequences
  jj --ignore-working-copy ${JJFZF_ATOP:+--at-op $JJFZF_ATOP} log --color=always --no-graph -s --git -T ' "\n" ++ jj_fzf_showdetails' -r "$R" |
    sed -r "1 { /^$/d }; /^(($E)?diff\b *--git)/{s//\n\1/}" |	# insert newline between stats and diff
    $JJFZFPAGER
)
FUNCTIONS+=( 'logrev' )

# Log flat change history
DOC['log']='Use `jj log` to browse the history including patches, starting from the selected revision.'
log()
{
  R="$(xrev "${1:-@}")"
  exec $SELF logrev "$R" --all
}
KEYBINDINGS["Ctrl-L"]="log"

# Duplicate Commit
DOC['duplicate']='Use `jj duplicate` to duplicate the changes of the currently selected revision and apply the changes on top of the working-copy.'
duplicate()
(
  R="$(xrev "${1:-@}")"
  # ensure empty working copy
  test $(rev_edpstate @) == empty-silent-p1 || {
    ( set -x; jj new ) || die
  }
  # record working-copy and children before/after, then duplicate
  W="$(xrev "@")"
  A=( $(rev_children "$R-") )
  ( set -x
    jj duplicate "$R"
  ) || die
  B=( $(rev_children "$R-") )
  # find duplicate commit, move into @-
  C=() && diff_arrays A B C
  [ ${#C[@]} -eq 1 ] ||
    die "failed to find newly created revision duplicate"
  ( set -x
    jj rebase -r "${C[0]}" --insert-before "$W"
  ) || die
)
KEYBINDINGS["Alt-U"]="duplicate"	FIRSTS="$FIRSTS duplicate"

# vivifydivergent
DOC['vivifydivergent']='When a revision has more than one visible commit, it becomes a divergent revision. This command uses `jj new+squash …` to create a new *change_id* for the currently selected divergent revision, effectively resolving the divergence.'
vivifydivergent()
(
  # fetch commit_id of a divergent revision
  COMMIT="$(xrev_or_commit "${1:-@}")" &&
    COMMIT=$(divergent_commitid "$COMMIT") ||
      die 'no divergent revision'
  echo "$SELF vivifydivergent $COMMIT" >&2
  jj log --no-graph -T builtin_log_oneline -r "$COMMIT"
  # Find change_id for commit
  R=`jj log --no-graph -T change_id -r "$COMMIT"` ||
    die 'no divergent revision'
  # Set @ to newly inserted empty commit before $R
  ( set -x
    jj new --before "$COMMIT" )
  # Figure new commit ID of $R
  NEWCOMMIT=$(divergent_commitid '@+') ||
    die 'lost divergent revision after new'
  # Squash commit ID of $R into @, auto-deleting the divergent revision
  ( set -x
    jj squash --from "$NEWCOMMIT" --into @ )
  jj log --no-graph -T builtin_log_oneline -r @
)
KEYBINDINGS["Alt-V"]="vivifydivergent"	NEXTS="$NEXTS vivifydivergent"

# Gitk View
DOC['gitk']='Start `gitk` to browse the *Git* history of the repository.'
gitk()
(
  R="$(xrev "${1:-@}")"
  jj git export --quiet
  COMMIT="$(rev_commitid "$R")"
  cd "$JJROOT"
  git update-index --refresh || :
  #test -e "$JJROOT/.jj/repo/store/git" && export GIT_DIR="$JJROOT/.jj/repo/store/git" || export GIT_DIR="$JJROOT/.git"
  # readarray -t HEADS < <( jj --ignore-working-copy log --no-graph -T 'commit_id ++ "\n"' -r ' heads(::) ' )
  # beware gitk is executable and sh function
  ( set -x
    exec gitk --branches --tags --remotes --select-commit=$COMMIT $COMMIT HEAD -- # "${HEADS[@]}"
  )
  jj git import --quiet
)
KEYBINDINGS["Ctrl-V"]="gitk"

# Edit (New) Working Copy
DOC['edit-workspace']='Use `jj {edit|new}` to set the currently selected revision (or divergent commit) as the working-copy revision. Will create a new empty commit if the selected revision is immutable.'
edit-workspace()
(
  R="$(xrev_or_commit "${1:-@}")" ||
    die "no such revision"
  IMMU=$($JJFZFSHOW -r "$R" -T 'if(immutable, "true")')
  [[ $IMMU =~ ^true ]] && CMD='new' || CMD='edit'
  ( set -x
    jj $CMD -r "$R" ) ||
    sleep 1
)
KEYBINDINGS["Ctrl-E"]="edit-workspace"

# Swap Commits
DOC['swap-commits']='Use `jj rebase --insert-before` to quickly swap the currenly selected revision with the revision immediately before it.'
swap-commits()
(
  R="$(xrev "${1:-@}")"
  jj rebase -r "$R" --insert-before "$R-"
)
KEYBINDINGS["Alt-X"]="swap-commits"

# Undo last JJ op
DOC['undo']='Use `jj op undo` to undo the last operation performed by `jj` that was not in itself undone or an undo operation.'
undo()
(
  temp_dir
  # turn each undone operation "123abc" into an sed delete command
  undone_log |
    sed -r 's|([a-f0-9]+)|	/\\b\1/d	|' > $TEMPD/delops.sed
  # list operation IDs, skipping undone ones
  jj op log --no-graph -T 'self.id().short(16) ++ " " ++ self.description().first_line() ++ "\n"' |
    sed -rf $TEMPD/delops.sed > $TEMPD/undoable-ops.lst
  # fetch first
  read op rest < $TEMPD/undoable-ops.lst
  # read -p "Undo $op? " YN ; [[ "${YN:0:1}" =~ [yY] ]] || exit
  ( set -x
    jj op undo $op
  ) || sleep 1
)
KEYBINDINGS["Alt-Z"]="undo"

# == --help ==
HELPKEYS=$(declare -p KEYBINDINGS) && declare -A HELPKEYS="${HELPKEYS#*=}"	# copy KEYBINDINGS -> HELPKEYS
HELPKEYS[Ctrl-↑]='preview-up'
DOC['preview-up']='Scroll the preview window.'
HELPKEYS[Ctrl-↓]='preview-down'
DOC['preview-down']='Scroll the preview window.'
HELPKEYS[Ctrl-U]='clear-filter'
DOC['clear-filter']='Discard the current *fzf* query string.'
HELPKEYS[recent7]='default revset'
KEYS="${!HELPKEYS[@]}"
KEYS=$(sort <<<"${KEYS// /$'\n'}")
if [[ "${1:-}" = --help ]] ; then
  [[ " $* " =~ --color ]] && COLOR=true || COLOR=false
  ( :
    cat <<-\__EOF__
	# JJ-FZF
	 
	The **jj-fzf** shell script is a convenience script that wraps a number of
	jj commands, based on the `jj log` graph view. The commands executed to
	modify history are printed on stderr for the user to retrace the repository
	modifications.
	All commands are available via the following Keyboard shortcuts:
	__EOF__
    for k in $KEYS ; do
      NAME="${HELPKEYS[$k]}"
      echo
      echo "*$k:* **$NAME**"
      D="${DOC[$NAME]:-}"
      test -z "$D" ||
	echo "$D" | fold -s -w78 | sed 's/^/  /'
    done
  ) | (
    B=$'\e[1m'              # Bold
    T=$'\e[32;1;4m'         # Title
    C=$'\e[36m'             # Code
    I=$'\e[3m'              # Italic
    U=$'\e[4m'              # Underline
    Z=$'\e[0;24m'           # Reset
    W='[][<>{}A-Z| $@a-z0-9 ←-⇿ :…+-]'      # Word like chars (english)
    SEDSCRIPT="
    s/\r\`\`\`+\w*(([^\`]*|\`[^\`])+)\r\`\`\`+/$C\1$Z\n/g           # Code block with backticks
    s/\r~~~+\w*(([^~]*|~[^~])+)\r~~~+/$C\1$Z\n/g                    # Code block with tilde
    s/(^|\r)##* ([^\r]+)[ #]*\r/\1$T\2$Z\r/g        # Headings (Title)
    s/(\r\s?\s?)[-*] (\w+\b:)?/\1$B* \2$Z/g         # List bullet
    s/(\s)\*\*($W+)\*\*/\1$B\2$Z/g          # Bold
    s/(\s)\*($W+)\*([^*])/\1$I\2$Z\3/g              # Italic
    s/(\s)_($W+)_([^_])/\1$U\2$Z\3/g                # Underline
    s/(\s)\`($W+)\`([^\`])/\1$C\2$Z\3/g             # Code
    s/\r?<!--([^-]|-[^-]|--[^>])*-->//g             # Html Comments
    s,(\bhttps?://[^ ()\r]+),$U\1$Z,g               # Link
    "
    tr \\n \\r |
      { $COLOR && sed -re "$SEDSCRIPT" || cat ; } |
      tr \\r \\n
  )
  exit 0
fi

# == Function calling ==
if [[ "${1:-}" =~ ^[a-z0-9A-Z_+@-]+ ]] && [[ " ${KEYBINDINGS[@]} ${FUNCTIONS[@]} " =~ \ $1\  ]] ; then
  # Sync JJ with working-copy before func, probably has JJ_CONFIG: snapshot.auto-track="none()"
  jj status >/dev/null
  FUNC="$1" "$@" && E=$? || E=$?
  # Sync JJ after modifications, so user snapshot config and snapshot errors take effect
 ( unset JJ_CONFIG ; jj status || : ) >/dev/null
  exit $E
fi

# == Sync ==
# Sync JJ before starting FZF, so user snapshot config and snapshot errors take effect
( unset JJ_CONFIG
  set -x
  jj status
) || exit $?

# == Help / Docs ==
WHITE="                                                                                "
HEADER=""
test "$COLUMNS" -ge 166 && W=3 || { test "$COLUMNS" -ge 114 && W=2 || W=1 ;}
i=0
for k in $KEYS ; do
  S="$k: ${HELPKEYS[$k]}"	# printf(1) cannot count UTF-8 continuation chars (0x80-0xBF)
  test ${#S} -lt 26 && S="$S${WHITE:0:$(( 26 - ${#S} ))}"	# so, format like %-26s
  HEADER="$HEADER$S" #$HIGH"
  i=$(($i+1))
  test 0 == $(($i % $W)) &&
    HEADER="$HEADER"$'\n' ||
      HEADER="$HEADER "
done

# == SWITCHES ==
TRACK=--track	# not in fzf-0.29
FZFHELP="$(fzf --help 2>&1)" && [[ "$FZFHELP" =~ "--track" ]] || TRACK=

# == RELOAD ==
RELOAD='reload(eval "$FZF_DEFAULT_COMMAND")'

# == FZF ==
BIND=()
for k in "${!KEYBINDINGS[@]}" ; do
  fun="${KEYBINDINGS[$k]}"
  postcmd=""
  [[ " $FIRSTS " == *" $fun "* ]] && postcmd="+first"
  [[ " $NEXTS " == *" $fun "* ]] && postcmd="+down"
  BIND+=( --bind "${k,,}:execute( $SELF $fun {} {q} )+$RELOAD$postcmd" )
done

if test -z "${TEMPD:-}" ; then
  temp_dir
  export JJFZF_OUTER_TEMPD="$TEMPD"
fi
jj_config >"$TEMPD/jjfzfconfig.toml"
export JJ_CONFIG="$TEMPD/jjfzfconfig.toml"

export FZF_DEFAULT_COMMAND="${JJLOGCMD[@]@Q}"
fzf \
  "${FZFSETTINGS[@]}" \
  --bind "ctrl-u:clear-query+clear-selection+clear-screen" \
  --bind "ctrl-z:execute( $JJSUBSHELL )+execute( jj --no-pager st )+$RELOAD" \
  --bind "enter:execute( $SELF logrev {} {q} )+$RELOAD" \
  "${BIND[@]}" \
  $TRACK \
  --preview " exec $SELF preview {} {q} " \
  --header "$HEADER" --header-first \
  --prompt '  :: > ' \
  --no-tac --no-sort +m
# Note, do not use 'exec' as last command, otherwise trap-handlers are skipped.
