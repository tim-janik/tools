#!/bin/bash
# This Source Code Form is licensed MPL-2.0: http://mozilla.org/MPL/2.0
set -Eeuo pipefail #-x
SCRIPTNAME=`basename $0` && function die  { [ -n "$*" ] && echo "$SCRIPTNAME: $*" >&2; exit 127 ; }
SELF="$0"

# == Config ==
# JJ repository
JJROOT=$(jj root) || die "$PWD: not a JJ repository"
JJFZFSHOW="jj --no-pager --ignore-working-copy show --tool true"

# == Utils ==
# Match JJ revision as first ASCII word (e.g. as in builtin_log_oneline)
REVPAT='^[^a-z()0-9]*([k-xyz]{7,})\ '
# Extract JJ revision from first word
xrev()		( [[ "$* " =~ $REVPAT ]] && rev_changeid "${BASH_REMATCH[1]}" )
# Look up full revision via JJ change_id
rev_changeid()	( $JJFZFSHOW -T 'change_id' -r "$1" )
# Look up full commit hash via JJ commit_id
rev_commitid()	( $JJFZFSHOW -T 'commit_id' -r "$1" )
# List all branches of a revision
rev_branches()	( $JJFZFSHOW -T 'concat(separate(" ",branches))' -r "$1" )
# Require .git directory and set GIT_DIR
require_git_dir()
{
  test -e "$JJROOT/.git" &&
    export GIT_DIR="$JJROOT/.git" || {
      test -e "$JJROOT/.jj/repo/store/git" &&
	export GIT_DIR="$JJROOT/.jj/repo/store/git" ||
	  die "$PWD: failed to find .git store"
    }
}
ERROR()
{
  FUNC="${FUNC:-$0}"
  echo "ERROR: ${FUNC:+$FUNC:}" "$*" >&2
  read -t 2
  exit
}

# == Helpers ==
# Echo signoff
echo_signoff()
(
  JJFZF_SIGNOFF=true	# config get jjfzf.signoff
  if test "${JJFZF_SIGNOFF:-true}" == true ; then
    echo # separating newline before signoff section
    $JJFZFSHOW -T 'format_detailed_signature(author) ++ "\n"' -r @ |
      sed -e 's/>.*/>/ ; s/^/Signed-off-by: /'
  fi
)

# == Functions ==
# Edit Commit Message
+jjdescribe()
(
  R="$(xrev "$1")"
  FILES=()
  test silent == "$($JJFZFSHOW -r "$R"  -T 'separate(" ",if(!description, "silent"))')" &&
    readarray -t FILES < <(jj log --no-graph -r "$R" -T '' -s | sed 's/^\w //')
  test ${#FILES[@]} -gt 0 && {
    M=$(printf "%s: \n" "${FILES[@]}")
    E=$(jj config get user.email) N=$(jj config get user.name)
    test -n "$E" -a -n "$N" && M="$M"$'\n\n'"Signed-off-by: $N <$E>"
    test -n "$M" && jj describe -r "$R" -m "$M"
  }
  jj describe -r "$R" ||
    sleep 1
)

# Merge into upstream branch
+jjmerge()
(
  set -x
  R="$(xrev "$1")"
  C="$(rev_commitid "$R")"
  BRANCH="$(rev_branches "$R") $C" &&	# pick first branch name or $C
    [[ $BRANCH =~ ([^ ]+) ]] && BRANCH="${BASH_REMATCH[1]}"
  require_git_dir
  # find upstream branch name
  UPSTREAMNAMES="master trunk main" DEST=
  for M in $UPSTREAMNAMES ; do
    test -n "$(git config --get branch.$M.remote)" && DEST="$M" && break
  done		# check tracking branch
  test -n "$DEST" ||
    for M in $UPSTREAMNAMES ; do
      test -n "$(git rev-parse origin/$M $M 2>/dev/null)" && DEST="$M" && break
    done	# check matching remote and local branch
  test -n "$DEST" || ERROR "failed to find upstream merge branch (tried $UPSTREAMNAMES)"
  # check for work in progress
  git --no-pager diff -U0 "$DEST..$BRANCH" |	# examine all branch changes
    egrep "^\+.*\b(XXX|WIP|FIXME)\b" &&		# work still to be done
    WARN="(WARNING: merge diff contains WIP keywords)" || WARN=
  # create merge msg
  TEMPD="`mktemp --tmpdir -d jjfzf0XXXXXX`" || die "mktemp failed"
  trap "rm -rf '$TEMPD'" 0 HUP INT QUIT TRAP USR1 PIPE TERM
  SEP="^^^^^^^^^^^^"
  echo -e "# $SEP DRAFT:  merge $BRANCH into $DEST ${WARN:+$WARN} $SEP # DELETE THIS" > "$TEMPD/MERGE.txt"
  echo -e "Merge branch '$BRANCH'\n\n* Branch commit log:" >> "$TEMPD/MERGE.txt"
  git log --pretty=$'\f%s%+b' "$DEST..$BRANCH" |
    sed '/^\(Signed-off-by\|Acked-by\|Tested-by\|Cc\):/d' |
    sed '/^$/d ; s/^/\t/ ; s/^\t\f/  /' >> "$TEMPD/MERGE.txt"
  echo_signoff >> "$TEMPD/MERGE.txt"
  # edit merge msg
  HO=`md5sum "$TEMPD/MERGE.txt"`
  $EDITOR "$TEMPD/MERGE.txt" &&
    HN=`md5sum "$TEMPD/MERGE.txt"` ||
      HN="$HO"
  test "$HO" != "$HN" ||
    ERROR "Merge aborted by user"
  # create merge
  jj new --no-edit -m "$(cat "$TEMPD/MERGE.txt")" "$DEST" "$BRANCH" ||
    sleep 1
)

# New
+jjnew()
(
  R="$(xrev "$1")"
  jj new "$R" ||
    sleep 1
)

# == Function calling ==
[[ "${1:-}" =~ \+jj ]] && {
  FUNC="$1" "$@"
  exit $?
}

# == Sync ==
# Synchronize before changes in git or @ mess up state during jj log
jj git import --quiet
jj status >/dev/null
jj git export --quiet

# == FZF ==
PREVIEW_REVISION='jj --no-pager --ignore-working-copy log --no-graph --color=always -T builtin_log_detailed -s --git -r'
LOADLOG="jj --no-pager --ignore-working-copy log --color=always -T builtin_log_oneline -r ::"
RELOAD="reload( $LOADLOG | { grep -P '^\W*$|'{q} || cat; } )"
fzf \
  --no-tac --no-sort \
  --ansi --no-mouse \
  --layout reverse-list \
  --disabled +m \
  --bind "ctrl-x:jump" \
  --bind "ctrl-z:ignore" \
  --bind='f11:change-preview-window(bottom,75%,border-horizontal|)' \
  --preview-window 'right,border-left' \
  --bind "alt-e:execute( $SELF +jjdescribe {} )" \
  --bind "alt-m:execute( $SELF +jjmerge {} )" \
  --bind "alt-n:execute( $SELF +jjnew {} )" \
  --bind "change:$RELOAD" \
  --preview "[[ {} =~ $REVPAT ]] || exit; $PREVIEW_REVISION \${BASH_REMATCH[1]}" \
  < <( $LOADLOG ) || :
