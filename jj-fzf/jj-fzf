#!/bin/bash
# This Source Code Form is licensed MPL-2.0: http://mozilla.org/MPL/2.0
set -Eeuo pipefail #-x
SCRIPTNAME=`basename $0` && function die  { [ -n "$*" ] && echo "$SCRIPTNAME: $*" >&2; exit 127 ; }
SELF="$0"

# == Config ==
# JJ repository
JJROOT=$(jj root) || die "$PWD: not a JJ repository"
JJFZFSHOW="jj --no-pager --ignore-working-copy show --tool true"
JJFZFPAGER="less -Rc"

# == Utils ==
# Match JJ revision as first ASCII word (e.g. as in builtin_log_oneline)
REVPAT='^[^a-z()0-9]*([k-xyz]{7,})\ '
# Extract JJ revision from first word
xrev()
(
  if [[ "$* " =~ $REVPAT ]] ; then	# jj log line
    rev_changeid "${BASH_REMATCH[1]}"
  elif [[ "$*" =~ ^([^\ ]+)$ ]] ; then	# revision identifier w/o whitespace
    rev_changeid "${BASH_REMATCH[1]}"
  fi
)
# Look up full revision via JJ change_id
rev_changeid()	( $JJFZFSHOW -T 'change_id' -r "$1" )
# Look up full commit hash via JJ commit_id
rev_commitid()	( $JJFZFSHOW -T 'commit_id' -r "$1" )
# List all branches of a revision
rev_branches()	( $JJFZFSHOW -T 'concat(separate(" ",branches))' -r "$1" )
# Require .git directory and set GIT_DIR
require_git_dir()
{
  test -e "$JJROOT/.git" &&
    export GIT_DIR="$JJROOT/.git" || {
      test -e "$JJROOT/.jj/repo/store/git" &&
	export GIT_DIR="$JJROOT/.jj/repo/store/git" ||
	  die "$PWD: failed to find .git store"
    }
}
ERROR()
{
  FUNC="${FUNC:-$0}"
  echo "ERROR: ${FUNC:+$FUNC:}" "$*" >&2
  read -t 2
  exit
}

# == Helpers ==
# Echo signoff
echo_signoff()
(
  JJFZF_SIGNOFF=true	# config get jjfzf.signoff
  if test "${JJFZF_SIGNOFF:-true}" == true ; then
    echo # separating newline before signoff section
    $JJFZFSHOW -T 'format_detailed_signature(author) ++ "\n"' -r @ |
      sed -e 's/>.*/>/ ; s/^/Signed-off-by: /'
  fi
)
echo_commit_msg()
(
  R="$1"
  FILES=()
  readarray -t FILES < <(jj log --no-graph -r "$R" -T '' -s | sed 's/^\w //')
  test ${#FILES[@]} -gt 0 &&
    printf "%s: \n" "${FILES[@]}" ||
      echo Empty...
  echo_signoff
)

# == Functions ==
FUNCTIONS=()
declare -A KEYBINDINGS

loadlog()
(
  if test -z "${1:-}" ; then
    # default, show decendants, ancestry around working copy
    jj --no-pager --ignore-working-copy log --color=always -T builtin_log_oneline -r '::@ | @-::'
  else
    # search pattern, filter on top of all entries
    jj --no-pager --ignore-working-copy log --color=always -T builtin_log_oneline -r :: | {
      grep -P "$1" || # invalid patterns like '*' show full log
	cat # -P '^\W*$|'"$1"
    }
  fi
  # TODO: squash entire description into oneline for grep
)
FUNCTIONS+=( 'loadlog' )

preview()
(
  R="$(xrev "${1:-@}" 2>/dev/null)" &&
    test -n "$R" ||
      exit
  jj --no-pager --ignore-working-copy log --no-graph --color=always -T builtin_log_detailed -s --git -r "$R"
)
FUNCTIONS+=( 'preview' )

# Abandon Commit
abandon()
(
  R="$(xrev "${1:-@}")"
  ( set -x
    jj abandon -r "$R" ) ||
    sleep 1
)
KEYBINDINGS["Alt-A"]="abandon"

# Commit (Interactive)
commit()
(
  R="$(xrev "${1:-@}")"
  # Edit commit msg if mutable
  IMMU=$($JJFZFSHOW -r "$R" -T 'if(immutable, "true")')
  [[ $IMMU =~ ^true ]] || {
    # fetch new / old description
    test silent == "$($JJFZFSHOW -r "$R"  -T 'separate(" ",if(!description, "silent"))')" &&
      M="$(echo_commit_msg "$R")" ||
	M="$($JJFZFSHOW -r "$R" -T 'separate(" ",description)')"
    [[ "$M" =~ Signed-off-by ]] ||
      M="$M$(echo; echo_signoff)"
    # create commit msg file
    TEMPD="`mktemp --tmpdir -d jjfzf0XXXXXX`" || die "mktemp failed"
    trap "rm -rf '$TEMPD'" 0 HUP INT QUIT TRAP USR1 PIPE TERM
    SEP="^^^^^^^^^^^^"
    echo -e "# $SEP DRAFT:  commit $R $SEP # DELETE THIS" > "$TEMPD/COMMIT.txt"
    echo "$M" >> "$TEMPD/COMMIT.txt"
    # edit commit msg
    HO=`md5sum "$TEMPD/COMMIT.txt"`
    $EDITOR "$TEMPD/COMMIT.txt" &&
      HN=`md5sum "$TEMPD/COMMIT.txt"` ||
	HN="$HO"
    test "$HO" != "$HN" ||
      ERROR "Commit aborted by user"
    # update commit msg
    jj describe --no-edit -m "$M" "$R" ||
      sleep 1
  }
  # open new empty working copy commit
  jj new "$R"
)
KEYBINDINGS["Alt-C"]="commit"

# Edit Commit Message
describe()
(
  R="$(xrev "${1:-@}")"
  test silent == "$($JJFZFSHOW -r "$R"  -T 'separate(" ",if(!description, "silent"))')" && {
    M="$(echo_commit_msg "$R")"
    test z "$M" ||
      jj describe -r "$R" -m "$M"
  }
  jj describe -r "$R" ||
    sleep 1
)
KEYBINDINGS["Alt-E"]="describe"

# Merge into upstream branch
merge()
(
  R="$(xrev "${1:-@}")"
  C="$(rev_commitid "$R")"
  BRANCH="$(rev_branches "$R") $C" &&	# pick first branch name or $C
    [[ $BRANCH =~ ([^ ]+) ]] && BRANCH="${BASH_REMATCH[1]}"
  require_git_dir
  # find upstream branch name
  UPSTREAMNAMES="master trunk main" DEST=
  for M in $UPSTREAMNAMES ; do
    test -n "$(git config --get branch.$M.remote)" && DEST="$M" && break
  done		# check tracking branch
  test -n "$DEST" ||
    for M in $UPSTREAMNAMES ; do
      test -n "$(git rev-parse origin/$M $M 2>/dev/null)" && DEST="$M" && break
    done	# check matching remote and local branch
  test -n "$DEST" || ERROR "failed to find upstream merge branch (tried $UPSTREAMNAMES)"
  # check for work in progress
  git --no-pager diff -U0 "$DEST..$BRANCH" |	# examine all branch changes
    egrep "^\+.*\b(XXX|WIP|FIXME)\b" &&		# work still to be done
    WARN="(WARNING: merge diff contains WIP keywords)" || WARN=
  # create merge msg
  TEMPD="`mktemp --tmpdir -d jjfzf0XXXXXX`" || die "mktemp failed"
  trap "rm -rf '$TEMPD'" 0 HUP INT QUIT TRAP USR1 PIPE TERM
  SEP="^^^^^^^^^^^^"
  echo -e "# $SEP DRAFT:  merge $BRANCH into $DEST ${WARN:+$WARN} $SEP # DELETE THIS" > "$TEMPD/MERGE.txt"
  echo -e "Merge branch '$BRANCH'\n\n* Branch commit log:" >> "$TEMPD/MERGE.txt"
  git log --pretty=$'\f%s%+b' "$DEST..$BRANCH" |
    sed '/^\(Signed-off-by\|Acked-by\|Tested-by\|Cc\):/d' |
    sed '/^$/d ; s/^/\t/ ; s/^\t\f/  /' >> "$TEMPD/MERGE.txt"
  echo_signoff >> "$TEMPD/MERGE.txt"
  # edit merge msg
  HO=`md5sum "$TEMPD/MERGE.txt"`
  $EDITOR "$TEMPD/MERGE.txt" &&
    HN=`md5sum "$TEMPD/MERGE.txt"` ||
      HN="$HO"
  test "$HO" != "$HN" ||
    ERROR "Merge aborted by user"
  # create merge
  jj new --no-edit -m "$(cat "$TEMPD/MERGE.txt")" "$DEST" "$BRANCH" ||
    sleep 1
)
KEYBINDINGS["Alt-M"]="merge"

# New
new()
(
  R="$(xrev "${1:-@}")"
  jj new "$R" ||
    sleep 1
)
KEYBINDINGS["Ctrl-N"]="new"

# Squash Committs
squash()
(
  R="$(xrev "${1:-@}")"
  test \
    empty-silent == "$($JJTMPL_R "$R"  -T 'separate(" ",if(empty && !description, "empty-silent"))')" -a \
    empty-silent == "$($JJTMPL_R "$R-" -T 'separate(" ",if(empty && !description, "empty-silent"))')" &&
    exec jj abandon -r "$R-"  # squash 2 empty via abandoning parent # FIXME if child is workdir, just edit @-
  jj squash -r "$R" || # --keep-emptied
    sleep 1
)
KEYBINDINGS["Alt-Q"]="squash"

# Edit (New) Working Copy
working_copy()
(
  R="$(xrev "${1:-@}")"
  IMMU=$($JJFZFSHOW -r "$R" -T 'if(immutable, "true")')
  [[ $IMMU =~ ^true ]] && CMD='new' || CMD='edit'
  jj $CMD -r "$R" ||
    sleep 1
)
KEYBINDINGS["Ctrl-W"]="working_copy"

# Show change
show()
(
  R="$(xrev "${1:-@}")"
  ( set -x
    jj show -s --git -r "$R" --color=always ) | $JJFZFPAGER
)
KEYBINDINGS["Ctrl-S"]="show"

# == Function calling ==
[[ "${1:-}" =~ ^[a-z0-9_]+ ]] &&
  [[ " ${KEYBINDINGS[@]} ${FUNCTIONS[@]} " =~ \ $1\  ]] && {
  FUNC="$1" "$@"
  exit $?
}

# == Sync ==
# Synchronize before changes in git or @ mess up state during jj log
jj git import --quiet
jj status >/dev/null
jj git export --quiet

# == FZF ==
RELOAD="reload( exec $SELF loadlog {q} )"
BIND=()
for k in "${!KEYBINDINGS[@]}" ; do
  BIND+=( --bind "${k,,}:execute( $SELF ${KEYBINDINGS[$k]} {} )+$RELOAD+refresh-preview" )
done

fzf \
  --no-tac --no-sort \
  --ansi --no-mouse \
  --layout reverse-list \
  --disabled +m \
  --bind "change:$RELOAD+refresh-preview" \
  --bind "ctrl-x:jump" \
  --bind "ctrl-z:ignore" \
  --bind='f11:change-preview-window(bottom,75%,border-horizontal|)' \
  --bind "enter:execute( $SELF show {} )+$RELOAD" \
  "${BIND[@]}" \
  --preview-window 'right,border-left' \
  --preview "exec $SELF preview {}" \
  < <( $SELF loadlog "" ) || :
