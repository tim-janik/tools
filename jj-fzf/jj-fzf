#!/bin/bash
# This Source Code Form is licensed MPL-2.0: http://mozilla.org/MPL/2.0
set -Eeuo pipefail #-x
SCRIPTNAME=`basename $0` && function die  { [ -n "$*" ] && echo "$SCRIPTNAME: $*" >&2; exit 127 ; }
SELF="$0"

# == Config ==
# JJ repository
JJROOT=$(jj root) || die "$PWD: not a JJ repository"
JJFZFSHOW="jj --no-pager --ignore-working-copy show --tool true"
JJFZFPAGER="less -Rc"
TEMPD=

# == Utils ==
# Create temporary dir, assigns $TEMPD
temp_dir()
{
  test -n "$TEMPD" || {
    TEMPD="`mktemp --tmpdir -d jjfzf0XXXXXX`" || die "mktemp failed"
    trap "rm -rf '$TEMPD'" 0 HUP INT QUIT TRAP USR1 PIPE TERM
  }
}
# Match JJ revision as first ASCII word (e.g. as in builtin_log_oneline)
REVPAT='^[^a-z()0-9]*([k-xyz]{7,})\ '
# Extract JJ revision from first word
xrev()
(
  if [[ "$* " =~ $REVPAT ]] ; then	# jj log line
    rev_changeid "${BASH_REMATCH[1]}"
  elif [[ "$*" =~ ^([^\ ]+)$ ]] ; then	# revision identifier w/o whitespace
    rev_changeid "${BASH_REMATCH[1]}"
  fi
)
# Look up full revision via JJ change_id
rev_changeid()	( $JJFZFSHOW -T 'change_id' -r "$1" )
# Look up full commit hash via JJ commit_id
rev_commitid()	( $JJFZFSHOW -T 'commit_id' -r "$1" )
# List all branches of a revision
rev_branches()	( $JJFZFSHOW -T 'concat(separate(" ",branches))' -r "$1" )
# Get revision description
rev_description() ( $JJFZFSHOW -T 'concat(description)' -r "$1" )
# Condense commit empty/description/parent state into a key word
rev_edpstate()
(
  export EDPSTATE='separate("-", if(empty, "empty", "diff"), if(description, "description", "silent"), "p" ++ self.parents().len()) ++ "\n"'
  $JJFZFSHOW -r "$1" -T "$EDPSTATE" # empty-description-p2 diff-silent-p1 etc
)
# Require .git directory and set GIT_DIR
require_git_dir()
{
  test -e "$JJROOT/.git" &&
    export GIT_DIR="$JJROOT/.git" || {
      test -e "$JJROOT/.jj/repo/store/git" &&
	export GIT_DIR="$JJROOT/.jj/repo/store/git" ||
	  die "$PWD: failed to find .git store"
    }
}
ERROR()
{
  FUNC="${FUNC:-$0}"
  echo "ERROR: ${FUNC:+$FUNC:}" "$*" >&2
  read -t 2
  exit
}

# == Helpers ==
# Echo signoff
echo_signoff()
(
  JJFZF_SIGNOFF=true	# config get jjfzf.signoff
  if test "${JJFZF_SIGNOFF:-true}" == true ; then
    echo # separating newline before signoff section
    $JJFZFSHOW -T 'format_detailed_signature(author) ++ "\n"' -r @ |
      sed -e 's/>.*/>/ ; s/^/Signed-off-by: /'
  fi
)
# Echo current or default message
echo_commit_msg()
(
  R="$1"
  S=$(rev_edpstate "$R")
  # keep existing message
  [[ $S =~ -silent- ]] || {
    rev_description "$R"
    return
  }
  # start with file name prefixes
  cd "$JJROOT" # create root relative file names
  FILES=()
  readarray -t FILES < <(jj log --no-graph -r "$R" -T '' -s | sed 's/^\w //')
  test ${#FILES[@]} -gt 0 &&
    printf "%s: \n" "${FILES[@]}" ||
      echo Empty...
  # ensure signoff
  echo_signoff
)
# Run user editor: user_editor_on_var <FILE> <VARIABLE>
user_editor_on_var()
{
  local FILE="$1" N=
  declare -n _ueovMSG="$2"			# <VARIABLE> alias
  # create msg file
  temp_dir
  local TEMPFILE="$TEMPD/$FILE"
  cat >"$TEMPFILE" <<<"$_ueovMSG"
  # edit commit msg
  $EDITOR "$TEMPFILE" &&
    N="$(cat "$TEMPFILE")" && {
      test "$_ueovMSG" != "$N" &&
	_ueovMSG="$(cat "$TEMPFILE")"
      rm -f "$TEMPFILE"
      return 0
    }
  rm -f "$TEMPFILE"
  return 1
}

# == Functions ==
FUNCTIONS=()
declare -A KEYBINDINGS

loadlog()
(
  if test -z "${1:-}" ; then
    # default, show decendants, ancestry around working copy
    jj --no-pager --ignore-working-copy log --color=always -T builtin_log_oneline -r '::@ | @-::'
  else
    # search pattern, filter on top of all entries
    jj --no-pager --ignore-working-copy log --color=always -T builtin_log_oneline -r :: | {
      grep -P "$1" || # invalid patterns like '*' show full log
	cat # -P '^\W*$|'"$1"
    }
  fi
  # TODO: squash entire description into oneline for grep
)
FUNCTIONS+=( 'loadlog' )

preview()
(
  R="$(xrev "${1:-@}" 2>/dev/null)" &&
    test -n "$R" ||
      exit
  export SHOWDETAILS='
concat(
  builtin_log_oneline,
  "Change ID: " ++ self.change_id() ++ "\n",
  "Commit ID: " ++ commit_id ++ "\n",
  surround("Refs:      ", "\n", separate(" ", local_branches, remote_branches, tags)),
  if(immutable, "Immutable: " ++ label("description placeholder", "true") ++ "\n"),
  "Parents:  " ++ self.parents().map(|c| " " ++ c.change_id()) ++ "\n",
  "Author:    " ++ format_detailed_signature(author) ++ "\n",
  "Committer: " ++ format_detailed_signature(committer)  ++ "\n\n",
  indent("    ",
    coalesce(description, label(if(empty, "empty"), description_placeholder) ++ "\n")),
  "\n",
)'	# extended version of builtin_log_detailed; https://github.com/martinvonz/jj/blob/main/cli/src/config/templates.toml
  E=$'\e\[[0-9;,]*m'	# \e[1;2m - match ANSI escape sequences
  jj --no-pager --ignore-working-copy log --no-graph --color=always -T "$SHOWDETAILS" -s --git -r "$R" |
    sed -r "0,/^(($E)?diff\b)/{s//\n\1/}"	# insert newline between stats and diff
)
FUNCTIONS+=( 'preview' )

# Abandon Commit
abandon()
(
  R="$(xrev "${1:-@}")"
  ( set -x
    jj abandon -r "$R" ) ||
    sleep 1
)
KEYBINDINGS["Alt-A"]="abandon"

# Commit (Interactive)
commit()
(
  R="$(xrev "${1:-@}")"
  # Edit commit msg if mutable
  IMMU=$($JJFZFSHOW -r "$R" -T 'if(immutable, "true")')
  [[ $IMMU =~ ^true ]] || {
    # fetch new / old description
    test silent == "$($JJFZFSHOW -r "$R"  -T 'separate(" ",if(!description, "silent"))')" &&
      M="$(echo_commit_msg "$R")" ||
	M="$($JJFZFSHOW -r "$R" -T 'separate(" ",description)')"
    [[ "$M" =~ Signed-off-by ]] ||
      M="$M$(echo; echo_signoff)"
    # create commit msg file
    TEMPD="`mktemp --tmpdir -d jjfzf0XXXXXX`" || die "mktemp failed"
    trap "rm -rf '$TEMPD'" 0 HUP INT QUIT TRAP USR1 PIPE TERM
    SEP="^^^^^^^^^^^^"
    echo -e "# $SEP DRAFT:  commit $R $SEP # DELETE THIS" > "$TEMPD/COMMIT.txt"
    echo "$M" >> "$TEMPD/COMMIT.txt"
    # edit commit msg
    HO=`md5sum "$TEMPD/COMMIT.txt"`
    $EDITOR "$TEMPD/COMMIT.txt" &&
      HN=`md5sum "$TEMPD/COMMIT.txt"` ||
	HN="$HO"
    test "$HO" != "$HN" ||
      ERROR "Commit aborted by user"
    # update commit msg
    jj describe --no-edit -m "$M" "$R" ||
      sleep 1
  }
  # open new empty working copy commit
  jj new "$R"
)
KEYBINDINGS["Alt-C"]="commit"

# Edit Commit Message
describe()
(
  R="$(xrev "${1:-@}")"
  O="$(rev_description "$R")"
  MSG="$(echo_commit_msg "$R")"
  user_editor_on_var "COMMIT.txt" MSG ||
    ERROR "Describe cancelled by user"
  test "$O" == "$MSG" || {
    jj describe --no-edit -r "$R" -m "$MSG" ||
      sleep 1
  }
)
KEYBINDINGS["Ctrl-E"]="describe"

# Split change
split-interactive()
(
  R="$(xrev "$1")"
  jj split --interactive -r "$R" ||
    sleep 1
)
KEYBINDINGS["Alt-I"]="split-interactive"

# Merge into upstream branch
merge-upstream()
(
  R="$(xrev "${1:-@}")"
  C="$(rev_commitid "$R")"
  BRANCH="$(rev_branches "$R") $C" &&	# pick first branch name or $C
    [[ $BRANCH =~ ([^ ]+) ]] && BRANCH="${BASH_REMATCH[1]}"
  require_git_dir
  # find upstream branch name
  UPSTREAMNAMES="master trunk main" DEST=
  for M in $UPSTREAMNAMES ; do
    test -n "$(git config --get branch.$M.remote)" && DEST="$M" && break
  done		# check tracking branch
  test -n "$DEST" ||
    for M in $UPSTREAMNAMES ; do
      test -n "$(git rev-parse origin/$M $M 2>/dev/null)" && DEST="$M" && break
    done	# check matching remote and local branch
  test -n "$DEST" || ERROR "failed to find upstream merge branch (tried $UPSTREAMNAMES)"
  # check for work in progress
  git --no-pager diff -U0 "$DEST..$BRANCH" |	# examine all branch changes
    egrep "^\+.*\b(XXX|WIP|FIXME)\b" &&		# work still to be done
    WARN="(WARNING: merge diff contains WIP keywords)" || WARN=
  # create merge msg
  TEMPD="`mktemp --tmpdir -d jjfzf0XXXXXX`" || die "mktemp failed"
  trap "rm -rf '$TEMPD'" 0 HUP INT QUIT TRAP USR1 PIPE TERM
  SEP="^^^^^^^^^^^^"
  echo -e "# $SEP DRAFT:  merge $BRANCH into $DEST ${WARN:+$WARN} $SEP # DELETE THIS" > "$TEMPD/MERGE.txt"
  echo -e "Merge branch '$BRANCH'\n\n* Branch commit log:" >> "$TEMPD/MERGE.txt"
  git log --pretty=$'\f%s%+b' "$DEST..$BRANCH" |
    sed '/^\(Signed-off-by\|Acked-by\|Tested-by\|Cc\):/d' |
    sed '/^$/d ; s/^/\t/ ; s/^\t\f/  /' >> "$TEMPD/MERGE.txt"
  echo_signoff >> "$TEMPD/MERGE.txt"
  # edit merge msg
  HO=`md5sum "$TEMPD/MERGE.txt"`
  $EDITOR "$TEMPD/MERGE.txt" &&
    HN=`md5sum "$TEMPD/MERGE.txt"` ||
      HN="$HO"
  test "$HO" != "$HN" ||
    ERROR "Merge aborted by user"
  # create merge
  jj new --no-edit -m "$(cat "$TEMPD/MERGE.txt")" "$DEST" "$BRANCH" ||
    sleep 1
)
KEYBINDINGS["Alt-M"]="merge-upstream"

# New --insert-before
new-before()
(
  R="$(xrev "${1:-@}")"
  jj new --insert-before "$R" ||
    sleep 1
)
KEYBINDINGS["Alt-N"]="new-before"

# New
new()
(
  R="$(xrev "${1:-@}")"
  jj new "$R" ||
    sleep 1
)
KEYBINDINGS["Ctrl-N"]="new"

# Squash Commits
squash()
(
  R="$(xrev "${1:-@}")"
  test \
    empty-silent == "$($JJTMPL_R "$R"  -T 'separate(" ",if(empty && !description, "empty-silent"))')" -a \
    empty-silent == "$($JJTMPL_R "$R-" -T 'separate(" ",if(empty && !description, "empty-silent"))')" &&
    exec jj abandon -r "$R-"  # squash 2 empty via abandoning parent # FIXME if child is workdir, just edit @-
  jj squash -r "$R" || # --keep-emptied
    sleep 1
)
KEYBINDINGS["Alt-Q"]="squash"

# Swap Commits
swap-commits()
(
  R="$(xrev "$1")"
  jj rebase -r "$R" --insert-before "$R-"
)
KEYBINDINGS["Alt-X"]="swap-commits"

# Undo last JJ op
undo()
(
  jj op undo
)
KEYBINDINGS["Ctrl-Z"]="undo"

# Edit (New) Working Copy
working-copy()
(
  R="$(xrev "${1:-@}")"
  IMMU=$($JJFZFSHOW -r "$R" -T 'if(immutable, "true")')
  [[ $IMMU =~ ^true ]] && CMD='new' || CMD='edit'
  jj $CMD -r "$R" ||
    sleep 1
)
KEYBINDINGS["Ctrl-W"]="working-copy"

# Show change
show()
(
  R="$(xrev "${1:-@}")"
  ( set -x
    jj show -s --git -r "$R" --color=always ) | $JJFZFPAGER
)
KEYBINDINGS["Ctrl-S"]="show"

# == Function calling ==
[[ "${1:-}" =~ ^[a-z0-9_]+ ]] &&
  [[ " ${KEYBINDINGS[@]} ${FUNCTIONS[@]} " =~ \ $1\  ]] && {
  FUNC="$1" "$@"
  exit $?
}

# == Sync ==
# Synchronize before changes in git or @ mess up state during jj log
jj git import --quiet
jj status >/dev/null
jj git export --quiet

# == Help / Docs ==
HELPKEYS=$(declare -p KEYBINDINGS) && declare -A HELPKEYS="${HELPKEYS#*=}"	# copy KEYBINDINGS -> HELPKEYS
HELPKEYS[Ctrl-↑]='preview-up'
HELPKEYS[Ctrl-↓]='preview-down'
KEYS="${!HELPKEYS[@]}"
KEYS=$(sort <<<"${KEYS// /$'\n'}")
WHITE="                                                                                "
HEADER=""
i=0
for k in $KEYS ; do
  S="$k: ${HELPKEYS[$k]}"	# printf(1) cannot count UTF-8 continuation chars (0x80-0xBF)
  test ${#S} -lt 26 && S="$S${WHITE:0:$(( 26 - ${#S} ))}"	# so, format like %-26s
  HEADER="$HEADER$S" #$HIGH"
  i=$(($i+1))
  test 0 == $(($i % 3)) &&
    HEADER="$HEADER"$'\n' ||
      HEADER="$HEADER "
done

# == FZF ==
RELOAD="reload( exec $SELF loadlog {q} )"
BIND=()
for k in "${!KEYBINDINGS[@]}" ; do
  BIND+=( --bind "${k,,}:execute( $SELF ${KEYBINDINGS[$k]} {} {q} )+$RELOAD+refresh-preview" )
done

fzf \
  --no-tac --no-sort \
  --ansi --no-mouse \
  --layout reverse-list \
  --disabled +m \
  --header "$HEADER" \
  --bind "change:$RELOAD+refresh-preview" \
  --bind "ctrl-x:jump" \
  --bind "ctrl-z:ignore" \
  --bind='f11:change-preview-window(bottom,75%,border-horizontal|)' \
  --bind "enter:execute( $SELF show {} {q} )+$RELOAD" \
  "${BIND[@]}" \
  --preview-window 'right,border-left' \
  --preview " exec $SELF preview {} {q} " \
  < <( $SELF loadlog "" ) || :
